\documentclass[oneside, a4paper, 11pt]{book}
\usepackage{style}
\usepackage{makeidx}
\makeindex
\usepackage{pdfpages}
\usepackage{rotating}
\usepackage{multicol}
\usepackage{mdframed}
\usepackage{tcolorbox}
\tcbuselibrary{breakable, skins}
\usepackage[english=british]{csquotes}
\usepackage[super]{nth}
\usepackage{xcolor}
\usepackage{xifthen} % if then else
\usepackage{subcaption}
\usepackage{amssymb}
\usepackage[font=footnotesize]{caption}
%\usepackage{fontawesome} % Symbole cadenas 
\usepackage{../package/mathpartir}
\usepackage{../package/drawstack}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{titlesec}
\usepackage[]{todonotes}
\usepackage{../package/formal-grammar}
\usepackage{wrapfig}
\usepackage{minted}
%\usepackage[backref=true]{biblatex}
% hyperref doit être chargé en dernier
\usepackage{hyperref}
\hypersetup{
	colorlinks=true,
	hidelinks=true,
}
\input{commands.tex}
%\addbibresource{ref.bib}


%%%%%% Macro %%%%%%

%% Todo Martin
\newcommand{\todoMV}[2][]{\todo[color=green, #1]{#2}}

\newcommand{\TLA}{\ensuremath{TLA^+~}}
\newcommand{\nats}{\ensuremath{\mathbb{N}}}


\newcommand{\ruleFmt}[1]{\textsc{(#1)}}
\newcommand{\ruleDef}[1]{\hypertarget{#1}{\ruleFmt{#1}}}
\newcommand{\ruleRef}[1]{\hyperlink{#1}{\ruleFmt{#1}}}

%% Trains
\definecolor{traincolor}{rgb}{0.2, 0.2, 0.6}
\newcommand{\trainFmt}[1]{{\color{traincolor} #1}}
\newcommand{\trainTuple}[4]{\langle \trainFmt{#1}, \posFmt{#2}, \dirFmt{#3}, #4 \rangle}
\newcommand{\trainTupleMF}[5]{\langle \trainFmt{#1}, \posFmt{#2}, \dirFmt{#3}, #4, \posFmt{#5} \rangle}
\newcommand{\trainSeq}{\ensuremath{\trainFmt{\Gamma}}}
\newcommand{\trains}{{\trainFmt{\mathsf{T}}}}
\newcommand{\tid}[1]{\ensuremath{\trainFmt{t_{#1}}}}



\newcommand{\forward}{\ensuremath{\mathtt{f}}}
\newcommand{\backward}{\ensuremath{\mathtt{b}}}
\newcommand{\sucblock}{{\mathtt{suc}}}
\newcommand{\tsucblock}{{\mathtt{tsuc}}}
\newcommand{\throughS}{{\mathtt{through}}}
\newcommand{\directions}{\dirFmt{\mathcal{D}}}
%% Train directions
\definecolor{dircolor}{rgb}{1.0, 0.13, 0.32}
\newcommand{\dirFmt}[1]{{\color{dircolor} #1}}
\newcommand{\dirForward}{\ensuremath{\dirFmt{\forward}}}
\newcommand{\dirBackward}{\ensuremath{\dirFmt{\backward}}}
\newcommand{\dirStop}{\ensuremath{\dirFmt{\star}}}

%% Positions
\definecolor{poscolor}{rgb}{0.6, 0.45, 0.32}
\newcommand{\posFmt}[1]{{\color{poscolor}{#1}}}
\newcommand{\blocks}{{\posFmt{\mathsf{B}}}}
\newcommand{\bid}[1]{\ensuremath{\posFmt{b_{#1}}}}
\newcommand{\suc}[3]{\ensuremath{\sucblock(\posFmt{#1}, \dirFmt{#2}, \swFmt{#3})}}
\newcommand{\tsuc}[3]{\ensuremath{\tsucblock(\posFmt{#1}, \dirFmt{#2}, \swFmt{#3})}}


%% Train program
\newcommand{\su}[2]{{\mbox{$\mathtt{startuntil}(\dirFmt{#1}, \posFmt{#2})$}}}
\newcommand{\trainConcat}[2]{#1 \cdot #2}
\newcommand{\emptyTrainProg}{\varepsilon}

%% Regulator
\newcommand{\handlerOf}[2]{\ensuremath{#1[\trainFmt{#2}]}}
\newcommand{\popHandlerHead}[2]{\ensuremath{{\tt pop}(#1[\trainFmt{#2}])}}
\newcommand{\substHandlerHead}[3]{\ensuremath{#1[\trainFmt{#2} \leftarrow #3]}}
\newcommand{\actionsOf}[1]{\ensuremath{#1.{\tt act}}}
\newcommand{\blockOf}[1]{\ensuremath{#1.{\tt block}}}
\newcommand{\handler}[2]{\tuple{#1, #2}}
\newcommand{\nextAct}[1]{\ensuremath{#1.{\tt cont}}}

%% Regulator's Program
\newcommand{\regTuple}[3]{\tuple{#1, #2, #3}}
\newcommand{\evGuard}[2]{\ensuremath{\mathtt{ev}(\trainFmt{#1}, #2)}}
\newcommand{\ev}[3]{\evGuard{#1}{#2}: #3}
\newcommand{\incr}[1]{{\mbox{\ensuremath{\mathtt{incr}(\posFmt{#1})}}}}
\newcommand{\turnOrder}[2]{{\mbox{\ensuremath{\mathtt{turn}(#1, #2)}}}}
\newcommand{\authOrder}{{\mbox{\ensuremath{\mathtt{auth}}}}}
\newcommand{\tokens}{\ensuremath{T}}
\newcommand{\tokenOf}[1]{\ensuremath{T(\posFmt{#1})}}
\newcommand{\regulator}{\ensuremath{R}}
\newcommand{\wait}[2]{{\mbox{\ensuremath{\mathtt{wait}(\posFmt{#1}, #2)}}}}
\newcommand{\regConcat}[2]{#1 \cdot #2}
\newcommand{\incrToken}[2]{\ensuremath{#1. {\tt incr}(\posFmt{#2})}}

%% Switches
\definecolor{swcolor}{rgb}{0.4, 0.23, 0.56}
\newcommand{\swFmt}[1]{{\color{swcolor}{#1}}}
\newcommand{\sid}[1]{\ensuremath{\swFmt{s_{#1}}}}
\newcommand{\turnouts}{\swFmt{\mathsf{\Theta}}}
\newcommand{\switches}{\ensuremath{\swFmt{\sigma}}}
\newcommand{\networkConf}{\ensuremath{\swFmt{\Sigma}}}
\newcommand{\nosuc}{\ensuremath{\swFmt{\bot}}}
\newcommand{\updateSwitch}[3]{\ensuremath{#1[\swFmt{#2}\leftarrow #3]}}

%% State
\newcommand{\stateTuple}[4]{\tuple{#1, #2, #3, #4}}

%% Guard
\definecolor{guardcolor}{rgb}{0.53, 0.66, 0.42}
\newcommand{\guardFmt}[1]{{\color{guardcolor} \ensuremath{\mathtt{#1}}}}
\newcommand{\guardT}{\guardFmt{T}}
\newcommand{\guardS}{\guardFmt{S}}
\newcommand{\guardR}{\guardFmt{R}}
\newcommand{\guardG}{\guardFmt{G}}
\newcommand{\guardM}{\guardFmt{M}}

%% Buffer
\newcommand{\bufferFmt}[1]{#1}
\newcommand{\head}[1]{\ensuremath{{\tt hd}(#1)}}
\newcommand{\buflen}[1]{\ensuremath{{\tt len}(\bufferFmt{#1})}}
\newcommand{\bufhead}[1]{\head{\bufferFmt{#1}}}
\newcommand{\buftail}[1]{\ensuremath{{\tt tl}(\bufferFmt{#1})}}
\newcommand{\emptyList}{\ensuremath{\varepsilon}}
\newcommand{\bufTrainSet}{\ensuremath{\bufferFmt{\mathbb{B}_t}}}
\newcommand{\bufSigSet}{\ensuremath{\bufferFmt{\mathbb{B}_s}}}
\newcommand{\bufTrain}{\ensuremath{\bufferFmt{B_t}}}
\newcommand{\bufSig}{\ensuremath{\bufferFmt{B_s}}}

%% Signals
\newcommand{\sigred}{{\mbox{${\color{red!50!black}\mathtt{r}}$}}}
\newcommand{\siggreen}{{\mbox{${\color{green!50!black}\mathtt{g}}$}}}
\newcommand{\deviate}{{\mbox{$\mathtt{v}$}}}
\newcommand{\direct}{{\mbox{$\mathtt{d}$}}}
\newcommand{\signalF}[2]{\ensuremath{\signals(\posFmt{#1}, \dirFmt{#2})}}
\newcommand{\signals}{\ensuremath{F}}
\newcommand{\setSignalsTo}[2]{\signals.{\tt set\_to}(#1, #2)}
\newcommand{\updateSfty}[4]{{\tt updateSfty}(\signals, #1, #2, #3, #4)}
\newcommand{\updateSignal}[4]{\ensuremath{#1[\tuple{\swFmt{#2}, \dirFmt{#3}}\leftarrow #4]}}


\newcommand{\push}[2]{\ensuremath{\mathtt{push}(#1, #2)}}
\newcommand{\pop}[1]{\ensuremath{\mathtt{pop}(#1)}}

%% Rule predicates
\newcommand{\requestS}[3]{\ensuremath{{\tt RequestS}(\trainFmt{#1}, \posFmt{#2}, #3)}}
\newcommand{\nextWait}[1]{\ensuremath{{\tt NextWait}(#1)}}

\newcommand{\reduces}{\ensuremath{\rightarrow}}
\newcommand{\redTuple}[4]{\ensuremath{\tuple{#1, \bufferFmt{#2}, \bufferFmt{#3}, #4}}}

%%%%% regle m0 %%%%%
\newcommand\concatM[2]{#1;#2}
\newcommand\train[4]{ \langle #1, #2, #3, #4 \rangle}
\newcommand\trainfull[4]{\langle \trainFmt{\Gamma} \cup \{ \train{#1}{#2}{#3}{#4} \} \rangle}
\newcommand\reg[6]{\langle #1, #2, #3, #4, #5, #6 \rangle}
\newcommand\majtab[3]{#1[#2] \gets #3}

%regle m1
\newcommand{\regM}[7]{\langle #1, #2, #3, #4, #5, #6, #7 \rangle}


\definecolor{commentcolor}{rgb}{0.45, 0.45, 0.45}
\newcommand{\commentaire}[1]{{\color{commentcolor}{#1}}}


%%%%%%% Document %%%%%%%%


\title{Rapport}
\author{Moi}


\begin{document}


\titleformat{\chapter}[display]
	{\normalfont\bfseries}{}{1em}{\Large\hspace{1em}}

\frontmatter
\maketitle

\chapter*{Remerciements}
\addcontentsline{toc}{chapter}{Remerciements}

\renewcommand{\contentsname}{Sommaire}
\tableofcontents

\mainmatter

\titleformat{\chapter}[display]
	{\normalfont\bfseries}{}{1em}{\Large\thechapter\hspace{1em}}

\chapter{Introduction}
\label{sec:intro}

\section{Contexte et objectifs}

\begin{wrapfigure}[12]{r}{0.28\textwidth}
	\begin{minipage}{0.28\textwidth}
		\centering
		\vspace{-0mm}
		\includegraphics[height=40mm, angle=-90]{../paper/maquette.png}
		\caption{La maquette}
		\label{fig:maquette}
	\end{minipage}
\end{wrapfigure}

\paragraph{}
Aujourd'hui, le transport ferroviaire représente une grande partie des déplacements de personnes et de marchandises, ce qui en fait un enjeu sociétal majeur.
Sa sécurité doit être mise au premier plan, un accident pouvant engendrer des pertes humaines et économiques considérables. C'est pourquoi la Société Nationale des Chemins de fer Français (SNCF) est considérée comme un opérateur d'importance vitale (OIV) par l'État français, ce qui implique un respect par cette dernière de normes de sécurité strictes, tant sur le plan "physique" que sur le plan "cyber". 
Dans le même temps, les besoins cyber dans l'industrie, mais également dans d'autres secteurs, poussent aux recrutements et à la formation de nouveaux profils.
C'est dans ce contexte que s'inscrit la création d'une maquette de train, simulant un réseau ferroviaire à l'échelle d'une ville. Cette dernière est utilisée pour offrir une plateforme d'entraînement aux étudiants participant à Cyber Humanun Est (CHE), dans l'optique de leur faire découvrir la défense et l'attaque de ce type de système.
\todo{Motivé la présence de la maquette~: on veut davoir pq des pb arrivent}L'objectif de ce stage consiste en la vérification d'un programme d'ordonnancement de trains~: être capable de certifier qu'une suite d'instructions précises n'engendre pas d'accidents et qu'elle permet d'acheminer les trains à bon port.
Cependant, avant de pouvoir vérifier ce programme, il est essentiel de modéliser notre système afin de simuler son comportement. Par la suite, nous pourrons utiliser des outils de vérification formelle, comme un model checker, pour confirmer que notre programme respecte bien les propriétés attendues.

\paragraph{Vocabulaire.}
Avant d'avancer dans la réflexion, il est important de définir quelques termes qui reviendront souvent dans ce document. On nomme canton une portion de voie ferrée, délimitée par des feux de signalisation, suivie par une impasse, un appareil de voie ou un autre canton. 
Un aiguillage représente une portion de voie qui offre un choix entre plusieurs cantons. Le réseau quant à lui représente l'ensemble des cantons et aiguillages. Enfin, un régulateur est une entité qui gère tout ou partie du réseau, dans notre cas, nous n'aurons qu'un seul régulateur. 

\section{Outils}

\paragraph{modèle}
\paragraph{règles}
\paragraph{tla}
\todo{mettre des paragraphes meme s'ils disparaissent, surtout pour voir si j'en dis assez}



\paragraph{}
Pour nous aider à atteindre notre objectif, nous avons utilisé plusieurs outils, aussi bien théoriques que pratiques.
Pour la modélisation, nous avons besoin d'outils théoriques comme les automates à états finis, une construction courante en informatique. Elle se présente comme un graphe orienté
où chaque sommet représente un état du système, et chaque arête une transition entre deux états, parfois étiquetée.
Dans notre cas, un état du système est représenté par l'état de tous les sous-systèmes qui le composent, comme les trains, le régulateur, etc... 
Mais nous verrons cela plus loin dans la section \ref{sec:modele}.
Chaque action modifie un état d'un des sous-systèmes, elle est alors représentée par une arête partant d'un état $e$ vers un état $e'$, on a donc ~: $e \xrightarrow{action} e'$.
Ici, on peut faire appel à un autre outil~: les règles d'inférences, qui vont représenter nos règles de transitions entre états, elles régissent les conditions sous lesquelles une transition peut se produire.
Ces dernières sont particulièrement utiles puisqu'elles permettent de représenter un comportement général~: une règle permet de décrire un ensemble d'arêtes dans l'espace d'états du système, voir figure \ref{fig:espaceEtat}.

\begin{wrapfigure}{r}{0.35\textwidth}
	\centering
	\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[
			vertex/.style={circle, draw=gray, fill=gray!15, very thick, minimum size=7mm, text width=1.5cm, align=center},
		]
		\node[vertex] (q0) at (4,0)	  {Attend pièce};
		\node[vertex] (q1) at (4,-5)  {Attend choix};
		\node[vertex] (q2) at (0,-10) {Prépare thé};
		\node[vertex] (q3) at (8,-10) {Prépare café};

		\draw[->] (q0) -- (q1) node[midway, right] {Pièce insérée};
		\draw[->] (q1) -- (q2)  node[midway, right] {Choix thé};
		\draw[->] (q1) -- (q3)  node[midway, right] {Choix café};

		\draw[->] (q2) .. controls (0,0) .. (q0) node[pos=0.3, right] {Thé prêt};
		\draw[->] (q3) .. controls (8,0) .. (q0) node[pos=0.3, right] {Café prêt};

		\end{tikzpicture}
	}
	\caption{Automate d'une machine à café}
	\label{fig:cafe}
\end{wrapfigure}



Une règle d'inférence se compose en deux parties, les prémisses et la conclusion. Nous utilisons les prémisses comme condition d'application de la règle, par exemple~: "le feu est vert", et la conclusion comme "effet" de la transition~: la voiture avance.
On écrira alors ~: $\inferrule*[left={règle}]{\text{feu = vert}}{\text{e $\rightarrow$ e'}}$. 
L'écriture de ces règles est cruciale pour la modélisation, car c'est le "moteur" du système, une condition mal formulée peut empêcher une transition légitime à nos yeux de se produire, alors qu'une condition trop permissive peut engendrer des transitions non souhaitées et fausser la "simulation".
Si on reformule, une condition trop stricte réduit l'ensemble de transition couvert par la règle, pouvant exclure des transitions légitimes, tandis qu'une condition trop permissive peut inclure des transitions indésirables, compromettant ainsi le modèle.
Si l'utilisation d'automates à états finis nous permets de modéliser le système, nous pouvons nous en servir également pour imager notre problématique, un état peut avoir plusieurs transitions possibles, il faut donc que, pour un programme donné, toutes les combinaisons de transitions possibles mènent vers un état final qui respecte nos propriétés.
Dans ce cadre, nous pouvons utiliser des outils de visualisation pour mieux comprendre les interactions entre les différents états et transitions.
Sur la figure \ref{fig:zoomCollision}, on remarque qu'à partir de certains états, on tombera forcément sur une collision (en rouge) ou sur un blocage (en jaune).

\begin{wrapfigure}{l}{0.5\textwidth}
	\centering
	\includegraphics[width=0.5\textwidth]{collision.jpg}
	\caption{Morceau d'un automate de notre système}
	\label{fig:zoomCollision}
\end{wrapfigure}

\noindent
Passons désormais en revue le dernier outil de notre panoplie principale~: \TLA. 
Ce dernier à été développé par Leslie Lamport dans les années 1990, il est utilisé pour modéliser et vérifier des programmes, notamment sur des systèmes distribués. \todo{Ajouter une citation / "pourquoi avoir choisi TLA"}
L'aspect le plus important de \TLA, pour nous, repose sur son model checker, TLC, qui permet d'explorer toutes les combinaisons de transitions évoquées précédemment.
\\
\paragraph{Plan.} Au cours de ce rapport, nous présenterons en détail le processus de modélisation et les différents modèles, en section \ref{sec:modele}. Puis, nous poursuivrons vers l'implémentation de ces modèles en \TLA dans la section \ref{sec:tla}.
Enfin, la section \ref{sec:experiences} présentera les expériences menées sur nos modèles, du protocole de test aux résultats obtenus.










\chapter{Cadre de travail}
\paragraph{} 
Ce stage prend place au sein du LORIA, le laboratoire lorrain de recherche en informatique et ses applications, il est divisé en 5 départements dans lesquels s'intègrent 28 équipes en fonctions de leurs spécialités.
L'équipe Véridis, qui m'accueille, est dirigée par Stephen Merz et se trouve au sein du département 2, consacré aux méthodes formelles. Quant à eux, les départements 1, 3, 4 et 5 sont respectivement dédiés aux thèmes suivants~: "Algoritmique, calculs, images et géométrie", "Réseaux, systèmes et services", "Traitement automatique des langues et des connaissances" et "Systèmes complexes et intelligence artificielle".
Pendant la durée de mon stage, j'ai été encadré par Guillaume Bonfante et Martin Vassor, un suivi régulier à raison d'une réunion par semaine permettait de faire le point sur l'avancement du sujet et de recentrer au besoin.
Bien qu'essayant de m'imposer une autonomie dans mon travail, mes encadrants ont toujours été présents pour répondre à mes questions ou me guider dans mes réflexions.
L'intégration au sein de l'équipe s'est déroulée naturellement, les échanges avec plusieurs membres de l'équipe m'ont permis d'élargir ma culture scientifique et de mieux comprendre les mécanismes de la recherche scientifique.

\todo{Peut-etre faire un truc chronologique : facile au début pour rentrer dans le sujet, puis de plus en plus complexe}


\chapter{Modélisation}
\label{sec:modele}

\todo{rattacher la maquette au réel, ce qui existe}

\begin{wrapfigure}{r}{0.3\textwidth}
	\centering
	\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[
			vertex/.style={circle, draw=gray, fill=gray!15, very thick, minimum size=7mm, text width=1cm, align=center},
			white/.style={circle, draw=white, fill=white, very thick, minimum size=7mm, text width=1cm, align=center},
			edge/.style={thick}
		]
		%\node[vertex] (q0) at (4,0)	  {Circuit maquette};
		\node[vertex] (q3)	  {3};
		\node[vertex] (q4) [right=40mm of q3] {4};
		\node[vertex] (q2) [above right=25mm and 35mm of q3] {2};
		\node[vertex] (q1) [above=20mm of q3] {1};
		\node[vertex] (q7) [below=30mm of q3] {7};
		\node[vertex] (q5) [below right=-3mm and 45mm of q7] {5};
		\node[vertex] (q8) [below right=10mm and 15mm of q3] {8};
		%\node[vertex] (q8) [below right=1cm and 2cm of q3] {8};
		\node[vertex] (q6) [above right=2mm and 25mm of q7] {6};

		\draw[->] 
		(q3)  edge[bend left=5]  node[midway, above=-1mm, sloped] {\backward,\swFmt{9d}/\swFmt{10v}} (q1)
		(q1) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{9d}/\swFmt{10v}}  (q3)
		(q2) edge[bend left=5] node[midway, below=-1mm, sloped] {\forward,\swFmt{9v}/\swFmt{10v}}  (q3)
		(q3) edge[bend left=5] node[midway, above=-1mm, sloped] {\backward,\swFmt{9v}/\swFmt{10v}}  (q2)
		(q3) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{11v}}  (q8)
		(q8) edge[bend left=5] node[midway, below=-1mm, sloped] {\backward,\swFmt{11v}}  (q3)
		(q3) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{10d}}  (q4)
		(q4) edge[bend left=5] node[midway, below=-1mm, sloped] {\backward,\swFmt{10d}}  (q3)
		(q3) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{11d}}  (q7)
		(q7) edge[bend left=5] node[midway, above=-1mm, sloped] {\backward,\swFmt{11d}}  (q3)
		(q7) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{12d}}  (q5)
		(q5) edge[bend left=5] node[midway, below=-1mm, sloped] {\backward,\swFmt{12vd}}  (q7)
		(q4) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{13d}}  (q5)
		(q5) edge[bend left=5] node[midway, below=-1mm, sloped] {\backward,\swFmt{13d}}  (q4)
		(q7) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{12v}}  (q6)
		(q6) edge[bend left=5] node[midway, below=-1mm, sloped] {\backward,\swFmt{12v}}  (q7)
		(q6) edge[bend left=5] node[midway, above=-1mm, sloped] {\forward,\swFmt{13v}}  (q4)
		(q4) edge[bend left=5] node[midway, below=-1mm=-1mm, sloped] {\backward,\swFmt{13v}}  (q6)

		;
		\end{tikzpicture}
	}
	\caption{Graphe modélisant la maquette}
	\label{fig:grapheMaquette}
\end{wrapfigure}

\paragraph{} 
La modélisation représente une étape essentielle, elle nous permet de construire un outil, le modèle, pour décrire un système. Ce modèle est un double formel du système réel, nous pouvons en extraire un comportement se rapprochant de la réalité et observer son évolution dans le temps. De cette manière, il est possible d'étudier ce système pour trouver des propriétés ou résoudres des problèmes.
Avant de rentrer en détail dans le processus de modélisation, rappelons rapidement notre problématique~: il nous faut vérifier un programme d'ordonnancement de trains.

\subparagraph{}
Nous allons donc commencer par modéliser la maquette pour obtenir un espace dans lequel nos trains évolueront. Cependant, la maquette contient beaucoup de données inutiles, comme la taille des cantons, les bâtiments ou bien la topographie. On va donc se concentrer sur les éléments qui nous intéressent en la représentant sous forme de graphe, c'est la figure \ref{fig:grapheMaquette}.
Ce dernier simplifie l'information sur la manière dont est structuré le réseau et nous renseigne sur l'adjacence des différents éléments.

Chaque sommet représente un canton, ils sont reliés entre eux par des arêtes symbolisant les aiguillages. Ces dernières portent une étiquette pour indiquer l'état des aiguillages concernés~: ainsi, "9d/10v" indique qu'il faut que les aiguillages 9 et 10 soient respectivement "direct" et "dévié" pour accéder à l'autre sommet. Nous verrons plus tard ce que ces termes désignent.
Grâce à ce graphe, nous avons construit une fonction prenant en paramètre la position \bid{i} d'un train, sa direction \dirFmt{d} et la configuration des aiguillages \swFmt{$\sigma$}, et retournant la position du canton suivant \bid{j}~: $\suc{b_i}{d}{\sigma} = b_j$. S'il n'existe pas de successeur, la fonction renvoie une valeur spéciale~: $\nosuc$.


\begin{figure}[h]
	\centering
	\resizebox{0.5\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[red] (1.25,0.25) rectangle (1.75,0.75);

		\fill[red!50!black] (0.5,0.25) circle (1.25mm);
		\fill[green!50!black] (2.5,0.25) circle (1.25mm);

		\draw (3.5,0) -- (6.5,0) node[midway,below] {2};
		\fill[green!50!black] (4,0.25) circle (1.25mm);
		\fill[red!50!black] (6,0.25) circle (1.25mm);
		\end{tikzpicture}
	}
	\caption{Schéma d'exemple}
	\label{fig:exSchema}
\end{figure}

Nous allons quelques fois utiliser un schéma similaire à celui sur la figure \ref{fig:exSchema} pour illustrer nos exemples, expliquons-le rapidement.
Ce schéma représente un réseau composé de deux cantons, numérotés 1 et 2. Chaque canton possède deux feux de signalisation, un à chaque extrémité, pouvant être rouge ou vert. Enfin, les formes géométriques colorées représentent les trains, ici c'est un rectangle.

\section{Première approche}

\paragraph{} 
Dans les prochaines section, nous allons aborder différents modèles, du plus simple au plus aboutie, et leurs différences afin de comprendre le cheminement qui a mené au modèle final. Il est important de comprendre notre méthode de travail pour mieux appréhender les évolutions futures.
Comme vue plus haut, la modélisation tend à exprimer des comportements au plus proche de la réalité sans en reproduire les détails jugée inutiles.
C'est pourquoi nous faisont évoluer le modèle de manière itérative, ajoutant progressivement de plus en plus d'éléments.
Une fois un modèle établie et son implémentation réalisée, nous pouvons tester son comportement et ses limites pour apporter des ajustements ou préparer le prochain modèle.
Le modèle zéro est le plus basique, reflétant grossièrement le comportement de la maquette, tandis que le modèle 3 se rapproche davantage de l'implémentation réelle de cette dernière.

\paragraph{Aiguillages.}
La modélisation des aiguillages est constante sur les différents modèles, nous allons donc la présenter ici. Nous ne travaillons qu'avec des aiguillages "1-to-2", c'est à dire qu'il permet de choisir entre deux voies.
Au départ du canton 3 il est possible de se diriger vers les cantons 1, 2 ou 4 grâce à un montage spécifique~: 
\begin{itemize}
	\item L'aiguillage 10 nous donne la possibilité d'aller vers le canton 4 ou l'aiguillage 9.
	\item L'aiguillage 9 nous permet d'accéder au canton 1 ou 2.
\end{itemize}
À noter, les aiguillages possèdent des identifiants dans la continuité des cantons.
Enfin, comme il est possible de choisir entre deux voies, ces derniers possèdent deux états~: un desservant chaque voie. Cet ensemble d'états est noté $\{d,v\}$, respectivement pour "direct" et "dévié". 

\section{Modèle zéro}
\paragraph{} Notre premier modèle est simple, il permet d'entrer dans le sujet, de se familiariser avec les concepts nouveaux, notamment les règles de transitions, et de servir de base pour les futures évolutions.
Pour cela, on souhaite modéliser le déplacement des trains en ne prenant en compte que les aiguillages et les cantons, laissant sur le côté les feux de signalisation.

\paragraph{Problématiques.} %Besoin de gérer des ressources critiques donc mise en place de jeton et d'ordres att/incr | définir un évènement
Au travers de ce modèle, nous cherchons à résoudre un des problèmes de l'ordonnancement~: la gestion de ressources critiques. 
Une ressources devient critique lorsqu'elle est convoitée par plusieurs trains, dans notre cas, il s'agit des cantons
Parfois, il y a une manière plus ou moins efficaces de considérer les ressources critiques~:

\begin{example}[Ressources critiques]
	~\\
	Soient $c_1 = [\bid{1},\bid{2},\bid{3}]$ et $c_2 = [\bid{4},\bid{2},\bid{1}]$ les cantons empruntés par deux trains \tid{1} et \tid{2}.
	On observe que ces trains partagent \bid{1} et \bid{2} : (i) On considère les deux ressources comme critiques, il faut donc déployer un mécanisme de sécurité sur chacun des cantons. 
	(ii) On remarque que pour \tid{1}, \bid{2} est après \bid{1}, alors que pour \tid{2}, \bid{2} est avant \bid{1}. Si on résoud le problème sur \bid{2} de sorte à ce que \tid{1} soit prioritaire, alors, lorsque \tid{1} libérera \bid{2}, \tid{2} pourra accéder à \bid{1} sans problème.
	\todoMV[inline]{Pourquoi ? Qu'est-ce qui permet d'en arriver à la conclusion du goulot d'étranglement ? Pourquoi 1 n'est pas un goulot d'étranglement non plus ?}
	%Voir le scénario \ref{scenar:goodEnding} pour un exemple concret.
\end{example}

La solution pour résoudre ce problème est de mettre en place un système de jetons, s'inspirant des sémaphores, permettant de donner à un train l'accès temporaire à une ressource.
Une fois la ressource consommée, le train indique qu'il a terminé en incrémentant la valeur de son jeton. 
La "réservation" ou la libération de ressource doit se faire via des évènements, des actions déclenchées par le régulateur lorsqu'un train entre dans un canton.

\subparagraph{}
Une seconde problématique de taille a émergée, lors de tests, pendant la réalisation de ce modèle~: le déclenchement des évènements doit se faire avant un moment précis.
Par exemple, si un train a besoin qu'un aiguillage soit dévié pour continuer sa route, il faut être certain que le régulateur exécute l'évènement de déviation avant que le train n'arrive à l'aiguillage.
Il faut donc nous assurer que l'aiguillage est dans la bonne position avant que le train ne le franchisse, si possible sans arrêter le train.


\paragraph{Trains.} 
Les trains sont représentés par un quadruplet contenant un identifiant, une position, une direction et un programme interne, on note cela $t_{id} = \trainTuple{id}{pos}{dir}{P}$, on appel $\trainFmt{\Gamma}$ l'ensemble des trains et $\trainFmt{\gamma}$ l'ensemble des identifiants de $\trainFmt{\Gamma}$.

Le type de l'identifiant varie selon le contexte, une forme géométrique ($\vartriangle,\square,\bigcirc,\dots$) sur les exemples pour faciliter la compréhension, ou un entier pour les implémentations (indexé sur 1 ou 0 selon le langage).

On définit la position comme un entier tel que $\posFmt{pos} \in \posFmt{\mathcal{B}}$, avec $\posFmt{\mathcal{B}}$ l'ensemble des cantons. 

L'ensemble des directions est noté $\directions = \{ \dirForward, \dirBackward, \dirStop \}$, avec $\dirForward$ pour forward, $\dirBackward$ pour backward et $\dirStop$ pour l'arrêt.

Enfin, notre train est capable de réaliser trois actions de lui-même~: démarrer, avancer et s'arrêter.
Le programme interne d'un train est représenté par une liste d'ordres successifs, sous la forme \su{d}{dest}, avec $\dirFmt{d} \in \directions \setminus \{\dirStop\}$, et $\posFmt{dest} \in \posFmt{\mathcal{B}}$.
Un ordre indique au train de se déplacer jusqu'à la position $\posFmt{dest}$ dans la direction $\dirFmt{dir}$. À l'arrivée, l'ordre est consommé pour laisser place au suivant.
On dit qu'un programme est bien formé s'il ne contient pas deux ordres \su{d}{\bid{i}} consécutifs avec la même direction.

\begin{sidebox}
	À l'origine, on comptait trois types d'ordre pour le train~: "Start(\dirFmt{dir})", "Until(\posFmt{dest})" et "Stop()", respectivement pour démarrer le train dans la bonne direction, avancer jusqu'à la cible et s'arrêter.
	Cependant, nous avons remarqué que tout programme bien formé comportait forcément une série d'ordre "Start(\dots)/Until(\dots)/Stop()". Admettons qu'un train souhaite faire demi-tour, notre modèle l'oblige à s'arrêter avant de repartir. On a donc la suite "Start(\dirFmt{d1})/Until(\posFmt{p1})/Stop()/Start(\dirFmt{d2})/Until(\posFmt{p2})/Stop()".
	Ainsi, pour simplifier l'écriture du programme des trains, nous avons fusionné les trois ordres pour devenir "StartUntil(\dirFmt{dir}, \posFmt{dest})", l'ordre stop est désormais implicite.
	\\La construction du programme du train reste, presque, inchangée jusque dans le dernier modèle, il est sans doute utile de présenter sa grammaire~:
	\vspace{0.3cm}\\
	\begin{grammar}
		\firstcasesubtil{T}{\concatM{seq}{T} \gralt \varepsilon}{}
		\firstcasesubtil{seq}{StartUntil(D,\posFmt{\mathcal{B}})}{}
		\firstcasesubtil{D}{\dirFmt{f} \gralt \dirFmt{b}}{}
	\end{grammar}
	\vspace{0.3cm}
\end{sidebox}

\todo{Mettre ce paragraphe en dehors et laisser la grammaire ?}

\noindent
Les informations que le train possède sont limitées, nous l'avons construit dans l'optique d'un \textit{train ignorant} qui se base uniquement sur ses variables internes et qui ne tient pas compte de l'état du régulateur ou des autres trains.
Les feux de signalisation n'existent pas encore, il faut donc que le train demande au régulateur l'autorisation pour se déplacer entre chaque tronçon.
Nous avons choisi cette modélisation pour centraliser l'aspect "commandement" dans le régulateur, qui sera présenté plus loin.

\paragraph{Régulateur.} %(until attend que les events soient tous dépiler pour s'exécuter, c'est de la triche mais ça explique pourquoi il n'y a pas besoin de auth)
Seconde partie de notre modèle, le régulateur contrôle l'ensemble du système, il donne les autorisations d'avancer aux trains et agit sur le trafic via des évènements.
Ce dernier est composé de six éléments~:

\begin{itemize}
	\item Les jetons : Notés J, ils représentent l'accès à une ressource, ici un canton. Il suffit d'incrémenter la valeur du jeton pour libérer cette ressource.
	 On les définit par $J~:~\posFmt{\mathcal{B}} \mapsto \nats$.
	\item La file d'attente : Notée W, elle permet de garder en mémoire les trains qui attendent une ressource, nous verrons plus loin son utilité. Elle est définie par $W~:~\posFmt{\mathcal{B}} \times \nats \mapsto \trainFmt{\gamma}$.
	\item Les autorisations : Notées A, elles représentent le nombre d'autorisations restantes pour chaque train, en clair, le nombre de cantons que chacun peut encore parcourir.
	 On les définit par $A~:~\trainFmt{\gamma} \mapsto \nats$.
	\item Le programme du régulateur : Noté E, il contient toute l'information sur les transformations futures du système. 
	 Il se compose de gestionnaires d'évènements, un par train, qui dictent les actions à réaliser en fonction des évènements déclenchés.
	\item Les pointeurs d'évènements : Notés Ne, ils sont indispensables aux gestionnaires d'évènements puisqu'ils indiquent quel évènement doit être traité. Il est définit de la même manière que A.
	\item L'état des aiguillages : Noté $\swFmt{\sigma}$, cet élément reflète la configuration actuelle des aiguillages du réseau. On définit le définit comme $\swFmt{\sigma}~:~\swFmt{s} \mapsto \{d, v\}$, avec $\swFmt{s}$ l'ensemble des aiguillages.
\end{itemize}
Dans les règles de transition, on représente le régulateur de deux manières, par un R ou par un sextuplet~: $\langle J,W,A,E,{\text Ne},\swFmt{\sigma} \rangle$.



\paragraph{Évènements.}
Parlons maintenant des ordres du gestionnaire, en voici une liste exhaustive~:
\begin{itemize}
	\item \texttt{wait(j, x)} : Attendre que le jeton \texttt{j} atteigne la valeur \texttt{x}.
	\item \texttt{incr(j)} : Incrémenter le jeton \texttt{j}.
	\item \texttt{turn(\swFmt{$s_i$}, e)} : Mettre l'aiguillage \swFmt{$s_i$} dans la position \texttt{e}.
\end{itemize}

\begin{example}
	Soient $\tid{1} = \train{\tid{1}}{\bid{3}}{\dirForward}{P}$ et $R = \langle J,W,A,E,{\text Ne},\swFmt{\sigma} \rangle$, on a $E[\tid{1}]~=~[[\wait{4}{1}],\dots]$ le gestionnaire d'évènements associé à \tid{1}.
	Le prochain évènement de \tid{1} est donc \wait{4}{1}, il doit attendre sur le canton 3 que le jeton associé au canton 4 atteigne la valeur 1.
\end{example}

\todoMV{Peut-être qu'il vaut mieux commencer par présenter les ordres, donner un exemple avec un seul event, puis ensuite passer aux handlers généraux.}

\noindent
Nous verrons comment ils intéragissent avec le modèle plus loin, lorsque nous parlerons des règles de transitions.
 \subparagraph{Gestionnaires.}
Comme défini précédemment, les gestionnaires sont indexés sur les trains, les évènements du gestionnaire $g_i$ sont donc déclenché par les mouvements du train \tid{i}.
Ce gestionnaire n'est autre qu'une liste de listes d'ordres~: $g_i = [[-],[-],\dots]$.

\begin{example}
	~\\
	Soit $\tid{1} = \train{\trainFmt{\square}}{\bid{1}}{\dirStop}{[\su{\dirBackward}{3}]}$ avec son gestionnaire d'évènements $g_1~=~[[\wait{2}{1}],[\turnOrder{1}{d}],[\turnOrder{1}{v}, \incr{2}]]$.

	Lors du démarrage du train, l'évènement \wait{2}{1} est exécuté, puis c'est au tour de \turnOrder{1}{d} lors du premier déplacement. Enfin, la liste [\turnOrder{1}{v}, \incr{2}] est traitée après le dernier déplacement, laissant le gestionnaire dans l'état suivant : $g_1 = [[],[],[]]$.
\end{example}

\noindent
Avec ça, on peut représenter un état du système par $\mathcal{M} : \langle \trainFmt{\Gamma}, R \rangle$.

\begin{example}[GoodEnding M0]
	~\\
	Modélisation de l'état initial d'un scénario en utilisant le modèle zéro~: (goodEnding / mettre schéma en annexe ?)
	\\$\trainFmt{\Gamma}~: \{t_1, t_2\}$ avec,
	\begin{itemize}
		\item[] $t_1 = \trainTuple{\square}{1}{*}{[\su{R}{3}]}$
		\item[] $t_2 = \trainTuple{\vartriangle}{4}{*}{[\su{L}{1}]}$
	\end{itemize}
	\vspace{0.3cm}
	$R~: \langle J,W,A,E,{\text Ne},S \rangle$ avec,	
	\begin{itemize}
		\item[] $J = [0,0,0,0]$
		\item[] $W = [(1,0) : 0, (1,1) : 0, .., (8,1) : 0]$
		\item[] $A = [2,0]$
		\item[] $E = \langle g_1, g_2 \rangle$
		\item[] ${\text Ne} = [0, 0]$
		\item[] $\swFmt{\sigma} = [d]$
	\end{itemize}
	\vspace{0.3cm}
	$g_1 = [[],[],[\turnOrder{5}{v}, \incr{2}]]$
	\\$g_2 = [[\wait{2}{1}],[],[]]$
	\vspace{0.5cm}\\
	\underline{Rappel}~: à ce stade, nous ne fournissons qu'un modèle sur lequel il est possible de créer des programmes d'ordonnancement. La création d'un programme, correcte ou non, reste à la charge de l'utilisateur.
\end{example}


\paragraph{Dynamique.} 
Les présentations avec les éléments du modèle terminées, il est temps de voir comment le modèle peut évoluer au fil du temps.
Comme expliqué dans l'introduction, ce sont les règles de transitions qui vont apporter du mouvement à notre modèle, permettant de modifier son état règle après règle. Nous allons voir ensemble quelques règles mais elles ne seront pas toutes couvertes.

La règle \ruleDef{Until} nous dit qu'un train \tid{m} à la position \bid{i}, qui se déplace dans la direction \dirFmt{d}, peut avancer à la position \bid{j} sous conditions que le régulateur ait donné son autorisation et que son évènement courant soit vide.
Si le train avance en \bid{j}, alors son autorisation est décrémentée.
\begin{mathpar}
	\inferrule*[left=\ruleDef{Until}]{
		\suc{\posFmt{b_i}}{\dirFmt{d}}{\swFmt{\sigma}} = \posFmt{b_j} \neq \nosuc
		\and 
		A[\trainFmt{t_m}] \neq 0
		\and 
		{\tt len}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]) = 0
	}{
		\langle \trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{\trainConcat{\su{d}{N}}{P}}, \reg{J}{W}{A}{E}{{\text Ne}}{\swFmt{\sigma}} \rangle
		\\\reduces
		\langle \trainfull{\trainFmt{t_m}}{\posFmt{b_j}}{\dirFmt{d}}{\trainConcat{\su{d}{N}}{P}}, \reg{J}{W}{A.{\tt decr}(\trainFmt{t_m})}{E}{{\text Ne}.{\tt incr}(\trainFmt{t_m})}{\swFmt{\sigma}} \rangle
	}
\end{mathpar}

\begin{figure}[h]
	\centering
	\resizebox{1\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		%Avant
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[red] (1.25,0.25) rectangle (1.75,0.75);

		\draw (3.5,0) -- (6.5,0) node[midway,below] {2};

		\draw (7,0) -- (10,0) node[midway,below] {3};
		\draw (7,0.4) -- (8,1) -- (10,1) node[midway,below] {4};
		\fill[green] (8.75,1.25) -- (9,1.75) -- (9.25,1.25) -- cycle;

		\draw[->] (11,0.5) -- (12,0.5) node[midway,above] {\ruleDef{Until}};

		%Apres
		\draw (13,0) -- (16,0) node[midway,below] {1};

		\draw (16.5,0) -- (19.5,0) node[midway,below] {2};
		\fill[red] (17.75,0.25) rectangle (18.25,0.75);
		

		\draw (20,0) -- (23,0) node[midway,below] {3};
		\draw (20,0.4) -- (21,1) -- (23,1) node[midway,below] {4};
		\fill[green] (21.75,1.25) -- (22,1.75) -- (22.25,1.25) -- cycle;
		\end{tikzpicture}
	}
	\caption{Avant/Après la règle Until}
	\label{fig:exUntil}
\end{figure}

\noindent
La règle \ruleDef{Until} permet de déplacer un train $\trainFmt{t_m} \in \trainFmt{\Gamma}$ sur un canton adjacent, on observe bien que \bid{i} devient \bid{j}, la valeur renvoyé par la fonction \texttt{suc{}}. 

Si on regarde du côté des prémisses, on retrouve notre demande d'autorisation~: $A[\trainFmt{t_m}] \neq 0$, le train est immobilisé si le compteur tombe à 0.
Pour trouver le prochain canton, on utilise la fonction $\suc{\posFmt{b_i}}{\dirFmt{d}}{\swFmt{\sigma}}$ définie plus tôt. Enfin, la dernière prémisse est un peu particulière~: ${\tt len}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]) = 0$, elle nous assure que le gestionnaire d'évènements du train est vide.
Cela règle le second point de la problématique de ce modèle. (pas convaincu que les gens comprennent pour le dernier)

Du côté de la conclusion, on remarque que la position du train est mise à jour, en passant de \posFmt{$b_i$} à \posFmt{$b_j$}. 
Évolution naturelle des choses, un canton de franchi signifie une autorisation en moins, avec une décrémentation du compteur~: $A.{\tt decr}(\trainFmt{t_m})$, et une mise à jour du pointeur d'évènements, avec une incrémentation de sa valeur~: ${\text Ne}.{\tt incr}(\trainFmt{t_m})$.

\subparagraph{}
Les règles doivent pouvoir traiter les ordres des évènements. On pourrait s'attendre à avoir une règle \ruleDef{Wait} et une règle \ruleDef{Incr}, l'une adossée à \texttt{wait} pour réserver un canton et la seconde adossée à \texttt{incr} pour le libérer.
Cependant, nous avons une permutation possible~: \texttt{wait} puis \texttt{incr}, mais aussi \texttt{incr} puis \texttt{wait}. Afin de représenter ces comportements, nous avons choisi d'introduire deux paires de règles~:

\todoMV{Qui correspondraient à quoi ? Explique d'abord l'objectif général, puis l'approche intuitive avec une paire de règle, puis pourquoi on a en fait 2 paires}.



\begin{mathpar}
	\inferrule*[left=\ruleDef{WaitBefore}]{
			\bufhead{E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]} = \wait{j}{x}  \\ J[j] \neq x
		}{
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{E}{Ne}{A}{W}{S}
			\\\reduces
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{{\tt pop}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]])}{Ne}{A}{\majtab{W}{(j,x)}{\trainFmt{t_m}}}{S}
		}
\end{mathpar}

\begin{mathpar}
	\inferrule*[left=\ruleDef{IncrAfter}]{
			\bufhead{E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]} = \incr{j}
			\and
			J[j] = x \\ W[(j, x+1)] = \trainFmt{w_{id}} \\ nextWait(\trainFmt{w_{id}},E[\trainFmt{w_{id}}]) = cptAuth
		}{
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{E}{Ne}{A}{W}{S}
			\\\reduces 
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J.{\tt incr}(j)}{{\tt pop}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]])}{Ne}{\majtab{A}{\trainFmt{w_{id}}}{cptAuth}}{W}{S}
		}
\end{mathpar}

\noindent
Les règles \ruleDef{WaitBefore} et \ruleDef{IncrAfter} vont de pair pour le cas où l'ordre d'attente est traité avant celui d'incrémentation pour une valeur de jeton donnée.
Ainsi, la première permet d'inscrire le train à la file d'attente~: $\majtab{W}{(j,y)}{\trainFmt{t_m}}$, tandis que la seconde incrémente le jeton et met à jour les autorisations~: $\majtab{A}{\trainFmt{w_{id}}}{cptAuth}$.
On remarque que les deux règles dépilent l'ordre de l'évènement actuel avec ${\tt pop}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]])$.

Si on regarde les prémisses de la règle d'incrémentation, on remarque que l'on fait appel à la fonction $nextWait(\trainFmt{w_{id}},E[\trainFmt{w_{id}}])$ qui cherche dans le gestionnaire d'évènements du train \trainFmt{$t_m$} le prochain ordre $wait(j,x)$ et calcule le nombre de cantons avant d'y accéder, s'il n'existe pas, il retourne la distance à l'arrivée.

\begin{mathpar}
	\inferrule*[left=\ruleDef{IncrBefore}]{
			\bufhead{E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]} = \incr{j} \\ J[j] = x \\ W[(j, x+1)] = \varepsilon
		}{
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{E}{Ne}{A}{W}{S}
			\\\reduces
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J.{\tt incr}(j)}{{\tt pop}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]])}{Ne}{A}{W}{S}
		}
\end{mathpar}

\begin{mathpar}
	\inferrule*[left=\ruleDef{WaitAfter}]{
			\bufhead{E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]]} = \wait{j}{x} \\ J[j] = x \\ nextWait(\trainFmt{t_m},E[\trainFmt{t_m}]) = cptAuth
		}{
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{E}{Ne}{A}{W}{S} 
			\\\reduces
			\trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{P}, \reg{J}{{\tt pop}(E[\trainFmt{t_m}][{\text Ne}[\trainFmt{t_m}]])}{Ne}{\majtab{A}{\trainFmt{t_m}}{cptAuth}}{W}{S}
		}
\end{mathpar}

\noindent
À l'inverse, il arrive que l'ordre d'attente soit traité après celui d'incrémentation, c'est alors le couple \ruleDef{IncrBefore} / \ruleDef{WaitAfter} qui prend le relais.

Ces deux règles reposent sur les mêmes mécanismes que les précédentes, à la différence que c'est \ruleDef{WaitAfter} qui va mettre à jour les autorisations du train \trainFmt{$t_m$}.
Il est important de remarquer que, dans ce cas, le train n'est pas ajouter à la file d'attente, ce qui a peu d'influence sur le comportement du modèle.


\paragraph{Limitations.}
Ce modèle étant très simple, il présente de nombreuses limitations et "simplification de la réalité", notamment la gestion des évènements. 
Actuellement, le lien entre le régulateur et les trains est très fort, un train est capable de savoir si l'évènement qu'il a déclenché est entièrement traité ou non, ce qui n'est pas convenable dans notre idée du "train ignorant".
De plus, cette manière de faire entraîne un problème d'atomicité des évènements~: il est possible qu'un morceau d'un évènement soit traité, de rendre la main à un train, puis de reprendre le traitement de l'évènement.
Pour limiter les problèmes, on voudrait rendre les évènements atomiques, c'est-à-dire que si le modèle commence le traitement d'un évènement, alors il va devoir terminer le traitement avant de faire avancer les trains ou de traiter un autre évènement.


\begin{example}[Atomicité]
	On se place sur le graphe de la maquette, voir \ref{fig:grapheMaquette}. Considérons les trains $t_1$ et $t_2$ respectivement dans les cantons 3 et 4, et l'aiguillage 11 à la position "v". Supposons que l'évènement d'attente de $t_1$ pour aller en 7 ait eu lieu.
	Dans le cas où l'évènement qui doit être traité est $[incr(7),turn(11,d)]$ il est possible d'avoir l'exécution suivante~:
	\begin{itemize}
		\item \ruleDef{IncrAfter} : débloque le train $t_1$.
		\item \ruleDef{Until} : le train $t_1$ avance dans le canton 8 grâce à l'aiguillage 11 en position "v".
		\item \ruleDef{Turn} : l'aiguillage est tourné en position "d".
	\end{itemize}
	Ce comportement aboutit à une impasse, $t_1$ est bloqué dans le canton 8 alors qu'il pensait entrer dans le canton 7. L'ordre au sein des évènements est important.
\end{example}


\paragraph{Python.}
Notre méthode de travail implique un développement conjoint du modèle théorique et de son implémentation, il est alors plus simple de valider des "morceaux" de modèle grâce à nos scénarios de test.
Cependant, il était prévu que l'implémentation soit faite en \TLA, langage de spécification formelle dont le fonctionnement n'était pas encore acquis à ce moment du stage.
Il a donc été décidé de développer un moteur de simulation en Python, permettant de tester les balbutiements du modèle zéro et d'avoir une intuition sur le fonctionnement de \TLA, voir plus section \ref{sec:tla}.


\begin{wrapfigure}{ht}{0.5\textwidth}
	\missingfigure{Schéma du moteur de simulation}
\end{wrapfigure}


Ces petits scripts Python nous permettaient de charger des scénarios de test et de visualiser le comportement du modèle sur un graphe. Les scénarios étant assez simple, il est facile de voir si le comportement attendu est respecté ou non.
La visualisation de la solution se faisait via la génération d'un fichier \texttt{svg} obtenus à partir d'un \texttt{.dot}. L'inconvénient majeur réside dans la vérification de la solution, si le graphe gagne en complexité, il ne pourra plus être analysé, voir affiché.
Le besoin de passer à un formalisme plus rigoureux comme \TLA+ s'est alors fait sentir.

\todo{étoffer ? Ajouter une side box pour l'archi du moteur ?}











%\newpage
\section{Modèle découplage}

\paragraph{Raffinement.} Le modèle précédent était très basique, nous avons soulevé plusieurs points d'amélioration, notamment sur l'atomicité des évènements ou avec l'ajout de nouveaux éléments. Nous allons donc façonner ce modèle de manière à corriger ces limitations, en terme d'ajout, les feux de signalisation entrerons en jeu.

L'autre grand changement qui doit être fait est la séparation de \trainFmt{$\Gamma$} et du régulateur, nous les considérons désormais comme des agents autonomes. Ainsi, les règles régissant le comportement de l'un ne doivent pas dépendre de l'état interne de l'autre.



\paragraph{Problématique.} Le découplage complet de \trainFmt{$\Gamma$} et R pose plusieurs défis, principalement sur l'exécution des évènements~: il n'est plus autorisé qu'un train vérifie si l'évènement courant est vide pour avancer, il avance s'il le peut.
Pour transmettre son avancement, le train pourra communiquer avec le régulateur via un canal de communication unidirectionnel. Ces messages ne seront pas traités instantanément, réalisme oblige, ce qui introduit un problème majeur~: le train peut avancer sans attendre la fin de l'évènement.
Dans certain cas cela ne pose aucun problème, cependant, si l'évènement comporte un ordre "wait(-)", alors il est impératif que le train s'arrête pour ne pas provoquer d'accident.

L'introduction des feux de signalisation va nous permettre de gérer ça en remplacant le système d'autorisation précédente, impossible à maintenir dans ce nouveau cadre.

\paragraph{Buffer.} Un troisème éléments fait son apparition dans l'état du système, le buffer, il est utilisé comme canal de communication entre les trains et le régulateur. C'est une file qui stocke les messages des trains en attendant que le régulateur les traite. 
Il est noté B, c'est une séquence de messages de la forme (\trainFmt{$t_m$},\posFmt{$b_i$}) avec $\trainFmt{t_m} \in \trainFmt{\gamma}$ et $\posFmt{b_i} \in \posFmt{\mathcal{B}}$.
Ainsi, un message (\trainFmt{$\triangle$},\posFmt{8}) indique au régulateur que le train \trainFmt{$\triangle$}, à un moment donné, est passé par le canton \posFmt{8}. Avec ce nouvel élément, la réprésentation d'un état du système évolue~: $\langle B, \trainFmt{\Gamma}, R\rangle$.


\paragraph{Trains.} Très peu de changement du coté des trains, seul le programme à été impacté. Il contient désormais la liste des cantons que le train doit parcourir, sans le départ, plutôt que simplement sa destination.
C'est une limitation qui a été observée au cours de la création du modèle découplage, il était impossible de modéliser un parcours du type~: "débuter en 3, traverser les cantons 7,6,4,3,7,5,4 puis s'arrêter en 3", il n'existait aucun moyen de distinguer le 3 de passage et le 3 final. Désormais, on gère ce genre de trajet aisément.

Aussi, maintenant que les trains et le régulateurs sont découplés, il faut envoyer des messages via le buffer pour déclencher les évènements. Pour cela, la quasi-totalité des règles concernant le train envoient des messages au buffer, excepté \ruleDef{UntilNext}.
Nous avons passé cette règle sous silence car elle n'apportait rien à la compréhension du modèle, cette dernière est similaire à \ruleDef{Until} à la différence qu'elle dépile un ordre du train lorsque la destination d'un \su{d}{[\dots]} est atteinte. Pour mieux comprendre ce choix, voici un petit exemple dans lequel toutes les règles du train envoient des messages au buffer~:


\begin{example}
	Soit un train $\train{\tid{i}}{7}{\dirFmt{\star}}{P}$ dont le programme est le suivant~: $P = [\su{d}{[3,4]}, \su{f}{[3]}]$, un demi-tour est donc effectué sur le canton 4. 
	Voyons l'exécution de cette portion~:
	\begin{itemize}
		\item \ruleDef{UntilNext} : Le train passe du canton 3 au canton 4, le programme devient $P = [\su{f}{[3]}]$ et le message (\trainFmt{$\tid{i}$},\posFmt{4}) est envoyé au buffer.
		\item \ruleDef{Start} : Le train change de direction et le message (\trainFmt{$\tid{i}$},\posFmt{4}) est envoyé au buffer.
	\end{itemize}
	Le buffer contient donc les messages suivants~: [\dots,(\trainFmt{$\tid{i}$},\posFmt{4}), (\trainFmt{$\tid{i}$},\posFmt{4}),\dots].
\end{example}

\noindent
Dans l'exemple ci-dessus, nous pouvons voir que le demi-tour à dupliqué les messages. Il est possible d'en tenir compte et d'ajouter un évènement vide, cependant cela rendrait la création de programme du régulateur plus complexe.
Parmi les différentes solutions envisageables, nous avons choisi de reporter l'envoi de messages sur la règle \ruleDef{Stop} car, dans un programme bien formé, après la règle \ruleDef{UntilNext}~: soit le train repart dans une autre direction, \ruleDef{Start} envoie un message, soit il s'arrête, \ruleDef{Stop} envoie un message.
Dans tous les cas, un seul message est envoyé, c'est le comportement que nous cherchons.

\begin{sidebox}
	La modification précédente impacte peu la grammaire du programme des trains~:
	\vspace{0.3cm}\\
	\begin{grammar}
		\firstcasesubtil{T}{\dots}{inchangée}
		\firstcasesubtil{seq}{StartUntil(D,N)}{}
		\firstcasesubtil{D}{\dots}{inchangée}
		\firstcasesubtil{N}{[ sections ]}{}
		\firstcasesubtil{sections}{\concatM{section}{sections} \gralt section \gralt \varepsilon}{} 
		\firstcasesubtil{section}{ \posFmt{\mathcal{B}}}{}
	\end{grammar}
\end{sidebox}


\paragraph{Régulateur.}	Côté régulateur plus de choses ont évolué, comme la disparition du pointeur d'évènements, Ne, ce dernier n'était plus utile car maintenant on ne dépile plus que les ordres mais aussi les évènements lorsqu'ils sont vides.
De cette manière, le premier évènement de chaque gestionnaire est toujours le prochain à traiter. 

\begin{wrapfigure}{r}{0.3\textwidth}
	\centering
	\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[
			vertex/.style={circle, draw=white, fill=white, very thick, minimum size=7mm, text width=1.5cm, align=center},
		]

			\node[vertex] (trains)	  {Trains};
			\node[vertex] (regulator) [right=3cm of trains] {R};
			\node[vertex] (feux) [below right=2cm and 1cm of trains] {Feux};

			\draw[->] (trains) -- (regulator) node[midway,above,sloped] {Messages} node[midway,below,sloped] {positions} ;
			\draw[->] (regulator) -- (feux) node[midway,above,sloped] {Évènements} node[midway,below,sloped] {mise à jour};
			\draw[->] (feux) -- (trains) node[midway,above,sloped] {Signal} node[midway,below,sloped] {{\siggreen,\sigred}} ;

		\end{tikzpicture}
	}
	\caption{Schéma de la communication entre les différents acteurs. En haut de l'arête, la méthode de communication, en bas, le type de données échangées.}
	\label{fig:infos}
\end{wrapfigure}

On introduit ensuite l'historique, une contre-mesure à la désynchronisation entre les trains et le régulateur, ce dernier pouvant avoir une image des choses bien en retard par rapport à la réalité des trains. On note l'historique H, que l'on définit $H~:~\trainFmt{\gamma} \mapsto \posFmt{\mathcal{B}}$.
Même si l'historique peut sembler redondant avec la position des trains, il n'en est rien. En effet, ce dernier représente la position des trains vue par le régulateur et non la véritable position, il est important de garder ça en tête. Même si, à la fin, ces variables convergent, elles ne représentent pas la même chose et n'ont donc pas besoin d'être cohérente entre-elles, il n'y a pas de redondance.

Ensuite, pour régler le problème d'atomicité, on introduit un mécanisme de garde, un booléen que l'on note G. On est alors capable de simuler une approche grand pas, tous les ordres sont traités d'un coup, avec une approche petit pas, chaque ordre de l'évènement est traité individuellement, le problème d'atomicité s'efface.
Pour être plus clair, si la garde est active, il faut traiter tous les ordres de l'évènement en cours pour la désactiver. Bien entendu, aucun train ne peut se déplacer si la garde est active.
C'est un élément qui va gagner de l'importance dans les modèles suivants, ici, il pose les bases du méta-contrôle~: un contrôle des règles applicables. Par exemple, la phrase "\textit{il faut traiter tous les ordres de l'évènement en cours}" signifie que les règles de déplacement des trains sont désactivées si la garde est active.

Dernière modification, l'intégration des feux de signalisation, noté F. Il sont présent à chaque extrémité d'un canton, pouvant prendre la couleur rouge ou verte, définit par $F~:~\posFmt{\mathcal{B}} \times \{\dirForward,\dirBackward\} \mapsto \{\siggreen, \sigred\}$. Ils permettent un contrôle des trains par le régulateur sans communiquer directement avec eux, ce système remplace les demandes d'autorisation pour avancer. Bien que plus complexe à gérer, il nous permets un plus grand découplage.
Avec toutes ces modifications, la nouvelle représentation du régulateur est la suivante~: $\regM{E}{J}{\swFmt{\sigma}}{W}{G}{H}{F}$.


\paragraph{Évènements.}
Un nouvel évènement est introduit, noté \authOrder, il est la contraction des ordres \texttt{wait} et \texttt{incr}. C'est un ordre particulier car il n'est utile que dans un cas précis, quand l'évènement d'un train contient un ordre \texttt{turn} impliquant un aiguillage qu'il sera le prochain à utiliser, c'est souvent le cas lorsqu'un train effectue un demi-tour. Prenons par exemple le parcours 8,3,7 sur la maquette, voir \ref{fig:grapheMaquette}, l'aiguillage doit être dans l'état "v" puis "d".
Maintenant que le train peut avancer sans avoir terminé l'évènement, il peut avancer vers le mauvais canton. C'est la que $\authOrder$ intervient, il indique que le train doit s'arrêter. Ainsi, la fonction \nextWait{~} ne recherche plus uniquement \texttt{wait} mais également $\authOrder$ pour gérer les feux, voir la règles \ruleDef{WaitAfter} plus loin.

\begin{example}[GoodEnding M1]
	~\\
	Modélisation de l'état initale d'un scénario en utilisant le modèle découplage~: (goodEnding / mettre schéma en annexe ?)
	\\$B~: []$ \commentaire{// vide}
	\vspace{0.3cm}
	\\$\trainFmt{\Gamma}~: \{t_1, t_2\}$ avec,
	\begin{itemize}
		\item[] $t_1 = \trainTuple{\square}{1}{*}{[\su{R}{[2,3]}]}$
		\item[] $t_2 = \trainTuple{\vartriangle}{4}{*}{[\su{L}{[2,1]}]}$
	\end{itemize}
	\vspace{0.3cm}
	$R~: \langle J,W,E,\swFmt{\sigma},G,H,F \rangle$ avec,	
	\begin{itemize}
		\item[] $E = \langle g_1, g_2 \rangle$
		\item[] $J = [0,0,0,0]$
		\item[] $\swFmt{\sigma} = [d]$
		\item[] $W = [(1,0) : 0, (1,1) : 0, .., (8,1) : 0]$
		\item[] $G = \texttt{false}$
		\item[] $H = [0, 0]$
		\item[] $F = [(\posFmt{3},\dirForward) : \sigred,(\posFmt{4},\dirBackward) : \sigred]$ \commentaire{// De base, tous les feux sont au vert}
	\end{itemize}
	\vspace{0.3cm}
	$g_1 = [[],[],[\turnOrder{5}{v}, \incr{2}]]$
	\\$g_2 = [[\wait{2}{1}],[],[]]$
\end{example}


\paragraph{Dynamique.}

Des modifications assez importantes sur le déplacements des trains ont été appliquées, voyons l'évolution de \ruleDef{until}~:

\begin{mathpar}
	\inferrule*[left=\ruleDef{Until}]{
		\suc{\bid{i}}{d}{\switches} = \bid{j} \neq \nosuc
		\and
		R.\signalF{\bid{i}}{d} = \siggreen
		\\\and
		\posFmt{N} = \posFmt{n} \cdot \posFmt{N'}
		\and
		\posFmt{N'} \neq \emptyList
		\and
		R.G = \texttt{false}
	}{
		\langle B, \trainfull{\trainFmt{t_m}}{\posFmt{b_i}}{\dirFmt{d}}{\trainConcat{\su{d}{{N}}}{P}}, R \rangle
		\\\reduces
		\langle \push{B}{(\trainFmt{t_m},\bid{j})}, \trainfull{\trainFmt{t_m}}{\posFmt{b_j}}{\dirFmt{d}}{\trainConcat{\su{d}{N'}}{P}}, R \rangle
	}
\end{mathpar}

\noindent
Premier changement, le régulateur s'écrit sous sa forme contractée, R. On remarque que notre découplage a bien fonctionné puisqu'aucun changement dans R n'est présent, uniquement une lecture des feux F, ce qui représente ce que le train voit, et de la garde G, nécessaire pour le bon fonctionnement du système.
Pour transmettre l'avancement du train, nous utilisons la fonction $\push{B}{(\trainFmt{t_m},\bid{j})}$, qui ajoute le message $(\trainFmt{t_m},\bid{j})$ au buffer B.


\begin{mathpar}
	\inferrule*[left=\ruleDef{StartEvent}]{
			\bufhead{B} = (\tid{m}, \bid{i})
		}{
			\langle B, \trainFmt{\Gamma}, \regM{E}{J}{\swFmt{\sigma}}{W}{false}{H}{F} \rangle
			\reduces
			\langle B, \trainFmt{\Gamma}, \regM{E}{J}{\swFmt{\sigma}}{W}{true}{\majtab{H}{\tid{m}}{\bid{i}}}{F} \rangle
		}
\end{mathpar}

\begin{mathpar}
	\inferrule*[left=\ruleDef{EndEvent}]{
			\bufhead{B} = (\tid{m}, \bid{i})
			\and
			\bufhead{E[\tid{m}]} = \varepsilon
		}{
			\langle B, \trainFmt{\Gamma}, \regM{E}{J}{\swFmt{\sigma}}{W}{true}{H}{F} \rangle
			\reduces
			\langle \pop{B}, \trainFmt{\Gamma}, \regM{\pop{\handlerOf{E}{\tid{m}}}}{J}{\swFmt{\sigma}}{W}{false}{H}{F} \rangle
		}
\end{mathpar}

\noindent
Nous avons ici les deux piliers permettant de rendre la gestion des évènements atomique. Ces deux règles sont assez simples, la première active la garde si un message est dans le buffer, tandis que la seconde la désactive et nettoie, suppression de l'évènement vide et du message actuel.
Ainsi, si nous appliquons la règles \ruleDef{StartEvent}, il faudra atteindre \ruleDef{EndEvent} pour déplacer un train ou exécuter un autre évènement.

\begin{mathpar}
	\inferrule*[left=\ruleDef{WaitAfter}]{
			\bufhead{B} = (\tid{m}, \bid{i})
			\and
			\bufhead{E[\tid{m}]} = \regConcat{\wait{\bid{\text{crit}}}{x}}{O^\prime}
			\and 
			\tokenOf{\bid{\text{crit}}} = x
			\\
			\nextWait{\handlerOf{E}{\tid{m}}} = \bid{\text{stop}}
			\and
			\texttt{handleTL}(\bid{i}, \bid{crit}) = F^\prime
		}{
			\langle B, \trainFmt{\Gamma},  \regM{E}{J}{\swFmt{\sigma}}{W}{\texttt{true}}{H}{F} \rangle
			\reduces
			\langle B, \trainFmt{\Gamma},  \regM{\pop{\head{E[\tid{m}]}[0]}}{J}{\swFmt{\sigma}}{W}{\texttt{true}}{H}{F^\prime} \rangle
		}
\end{mathpar}

\begin{figure}[h]
	\centering
	\resizebox{1\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[green!50!black] (0.5,0.25) circle (1.25mm);
		\fill[green!50!black] (2.5,0.25) circle (1.25mm);


		\draw (3.5,0) -- (6.5,0) node[midway,below] {2};
		\fill[green!50!black] (4,0.25) circle (1.25mm);
		\fill[green!50!black] (6,0.25) circle (1.25mm);

		\draw (7,0) -- (10,0) node[midway,below] {3};
		\fill[red] (8.25,0.25) rectangle (8.75,0.75);
		\fill[green!50!black] (7.5,0.25) circle (1.25mm);
		\fill[red!80!black] (9.5,0.25) circle (1.25mm);

		\draw (7,0.4) -- (8,1) -- (10,1) node[pos=0.6,below] {4};
		\fill[green] (8.5,1.25) -- (8.75,1.75) -- (9,1.25) -- cycle;
		\fill[red!80!black] (7.5,1) circle (1.25mm);
		\fill[green!50!black] (9.5,1.25) circle (1.25mm);

		\draw[->] (11,0.5) -- (12,0.5) node[midway,above] {\ruleDef{WaitAfter}};

		\draw (13,0) -- (16,0) node[midway,below] {1};
		\fill[red!80!black] (13.5,0.25) circle (1.25mm);
		\fill[green!50!black] (15.5,0.25) circle (1.25mm);


		\draw (16.5,0) -- (19.5,0) node[midway,below] {2};
		\fill[green!50!black] (17,0.25) circle (1.25mm);
		\fill[green!50!black] (19,0.25) circle (1.25mm);

		\draw (20,0) -- (23,0) node[midway,below] {3};
		\fill[red] (21.25,0.25) rectangle (21.75,0.75);
		\fill[green!50!black] (20.5,0.25) circle (1.25mm);
		\fill[red!80!black] (22.5,0.25) circle (1.25mm);

		\draw (20,0.4) -- (21,1) -- (23,1) node[pos=0.6,below] {4};
		\fill[green] (21.5,1.25) -- (21.75,1.75) -- (22,1.25) -- cycle;
		\fill[green!50!black] (20.5,1) circle (1.25mm);
		\fill[green!50!black] (22.5,1.25) circle (1.25mm);
		\end{tikzpicture}
	}
	\caption{Avant/Après la règle WaitAfter}
	\label{fig:exWaitAfter}
\end{figure}

\noindent
Maintenant au tour de la règle \ruleDef{WaitAfter}, c'est un bon exemple de gestion des feux. On aperçoit que la règle utilise la fonction \texttt{handleTL} pour transformer l'état des feux de signalisation.
Cette dernière assigne le vert aux feux du canton sur lequel le train attend, \bid{i}, et le rouge au canton désigné par \texttt{nextWait}, \bid{stop}.
De cette manière, le train est débloqué, son feu est vert, et le régulateur est certain qu'il ne ratera pas le prochain évènement grâce au feu rouge.
Pour revenir sur \texttt{nextWait}, même si la fonction porte le même nom, elle ne cherche plus uniquement l'ordre \wait{\bid{i}}{x}, mais aussi \authOrder.
\ruleDef{WaitAfter} fait partie des trois règles pouvant influencer l'état des feux de signalisation, avec \ruleDef{IncrAfter} et \ruleDef{Auth}.

\paragraph{Limitations.}
Le modèle découplage à plutôt bien répondu aux limitations précédemment évoqué pour le modèle zéro, notamment au niveau du découplage $\Gamma/R$ et de l'atomicité des évènements. Cependant, ce modèle est encore loin d'être parfait et compte de nombreuses imperfections.
Tout d'abord, le régulateur contrôle les feux de signalisation, mais il n'y a pas de raison pour que ceux-ci en fassent partie, il est possible de les considérer comme éléments du système à part entière. De plus, cela nous rapprocherait de la réalité en modélisant un comportement "fail-safe" pour ces derniers, nous reviendrons sur ce point dans la prochaine section.







\section{Modèle 2}
\paragraph{Raffinement.} Ce modèle à la volonté de se rapprocher encore plus de la réalité, en séparant les feux de signalisation du régulateur, mais aussi en séparant les aiguillages et la garde. Ce dernier élément n'a pas de prise avec le physique, c'est une manière de rendre atomique le traitement des évènements, c'est une méta-donnée.
Autre nouveauté, les trains sont placés en file d'attente avant le départ et le premier évènement permet de les débloquer, de cette manière c'est le régulateur qui donne l'ordre de départ.

\paragraph{Buffers.} Désormais les feux et le régulateur ne sont plus liés, il faut donc un moyen de communication pour que le régulateur commande les feux. Pour continuer dans la même direction, c'est un autre buffer qui sera employé.
Ce dernier sera noté \textbf{$B_s$} et défini par $B_s~: \nats \mapsto \posFmt{\mathcal{B}} \times \{\siggreen, \sigred\}$, les messages étant de la forme (\posFmt{$b_i$},$c$) avec $\posFmt{b_i} \in \posFmt{\mathcal{B}}$ et $c \in \{\siggreen, \sigred\}$.
Enfin, question de cohérence, le buffer entre les trains et le régulateur est renommé \textbf{$B_t$}.


\paragraph{Feux.}Les feux de signalisation sont maintenant des entités indépendantes, notées \textbf{F}, ils gardent la même définition que précédemment. Avec ce changement nous allons pouvoir intégrer le comportement "fail-safe" des feux permettant de garantir qu'aucun accident ne puisse arriver.
Ce comportement ne peut pas être contrôlé par d'autres éléments du système, il se traduit par la mise au rouge des feux dont le successeur est $\nosuc$ ou occupé par un train. 
Pour garantir ce niveau de sécurité, les feux doivent être recalculés après chaque mouvement de train ou évènement.


\paragraph{Régulateur.} Le régulateur à subit de nombreux changements sur ce modèle. Tout d'abord, la perte de la garde, des feux de signalisation et des aiguillages.

La file d'attente a aussi été retravaillée, désormais c'est une liste contenant des quadruplets $w$, où $w \in \posFmt{\mathcal{B}} \times \posFmt{\mathcal{B}} \times \nats \times \trainFmt{\gamma}$ \todo{Définition ok ?}. Un quadruplet $\langle \bid{src}, \bid{dest}, n, \tid{m} \rangle$ dans $W$ signifie que le train \tid{m} attend au canton \bid{src} que le jeton \tokenOf{\bid{dest}} soit égal à $n$.
De cette manière on simplifie notre modèle de plusieurs façons, plus besoin de stocker tous les couples (canton/jeton) comme avant, ce qui pouvait causer des problèmes pour des réseaux plus grand, mais également en centralisant les informations concernant l'attente des trains. 

Avec ce changement, nous pouvons écarter H, l'historique, qui n'est plus nécessaire car il servait principalement à retrouver le canton d'attente d'un train.
Le régulateur s'écrit donc maintenant $\langle E, J, W \rangle$.
\todo[inline]{renommer J en T}

\paragraph{Évènements.} La perte de l'historique encourage la modification des gestionnaires d'évènements car ce dernier nous servait à retrouver le canton de l'évènement en cours. Ainsi, nous integrons directement le numéro du canton dans l'évènement associé~: $g_1 : [\langle \bid{i}, [-]\rangle, \langle \bid{j}, [-]\rangle,\dots]$.
De nouveau, aucun problème de redondance car c'est la position à laquelle l'évènement est déclenché et non la position actuelle du train.

\subparagraph{} Aussi, avec la modification de la file d'attente, il est intéressant de se pencher plus en détail sur l'ordre \wait{j}{x} car il représente bien les dilemmes lié à la modélisation.
Ce dernier nous indique la ressource que le train attend, ainsi, d'un coup d'oeil sur le programme, nous sommes capable de savoir qu'un train \tid{1} avec l'évènement \wait{3}{x} est prioritaire au train \tid{2} avec l'évènement \wait{3}{x+1}.
Cependant, pour l'implémentation, nous avons besoin de connaitre la position du train pour le positionner dans la file d'attente, il serait donc plus pratique que $j$ désigne la position d'attente et non la ressource.
Ce qui, pour le même exemple donnerait, \wait{7}{x} et  \wait{4}{y}, moins intuitif pour l'humain.
C'est pourquoi nous avons fait le choix de garder $j$ comme la ressource, pour faciliter l'écriture et la lecture du programme du régulateur.

\begin{warnbox}
	Pour une question de fidélité nous présentons le modèle tel qu'il est, cependant, avec du recule nous avons remarqué qu'il était possible de simplifier le message envoyer par le train en envoyant que l'identifiant du train. Dans ce modèle, l'autre information n'est pas utilisé, ce problème est directement lié à notre méthode de travail~: les itérations peuvent introduire des données utiles à un moment, mais superflues par la suite. Dans notre cas, ces données n'ont pas été retirées.
\end{warnbox}

%ajout du numéro de canton dans le gestionnaire, mais pas de problème de cohérence :  c'est pas la position actuel du train mais l'endroit où le train à déclencher l'event, comme histo du modèle zéro

\begin{wrapfigure}{r}{0.3\textwidth}
	\centering
	\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[
			vertex/.style={circle, draw=gray, fill=white, very thick, minimum size=7mm, text width=0.5cm, align=center},
		]

		\node[vertex] (t)	  								  {\guardT};
		\node[vertex] (s)  [right=2cm of t]   		  		  {\guardS};
		\node[vertex] (r)  [below right=1cm and 1cm of t]	  {\guardR};

		\path[->] (r) edge[loop above] ();

		\draw[->] (t) -- (r);
		\draw[->] (t)  .. controls (1.5,-0.2) ..  (s);
		\draw[->] (r) -- (s);
		\draw[->] (s) .. controls (1.5,0.2) .. (t);
		\draw[->] (0,0.7) -- (t);

		\end{tikzpicture}
	}
	\caption{Différentes phases du système}
	\label{fig:Phases}
\end{wrapfigure}

\paragraph{Garde.} À ce stade, la garde n'est plus qu'un simple booléen, elle nous indique la \textit{phase} du système, une période où l'on restreint l'utilisation de certaines règles, il en existe trois~:

\begin{itemize}
	\item \textbf{T} : mouvement de trains autorisé, il est également possible de débuter le traitement d'un évènement.
	\item \textbf{R} : mouvement de trains non autorisé, le traitement d'un évènement est en cours.
	\item \textbf{S} : phase fail-safe pour les feux, mise à jour de ces derniers.
\end{itemize}

Résumons, nous avons à notre disposition trois champs considérés comme "méta-données" et quatre autres représentant l'état réel du système. On peut donc écrire $\mathcal{M} : \langle G, B_t, B_s, \langle \trainFmt{\Gamma},R,\swFmt{\sigma,F} \rangle \rangle$

\begin{example}[GoodEnding M2]
		~\\
	Modélisation de l'état initale d'un scénario en utilisant le modèle 2~:
	\\$G~: T$
	\vspace{0.3cm}
	\\$B_t~: []$ \commentaire{// vide}
	\vspace{0.3cm}
	\\$B_s~: []$ \commentaire{// vide}
	\vspace{0.3cm}
	\\$\trainFmt{\Gamma}~: \{t_1, t_2\}$ avec,
	\begin{itemize}
		\item[] $t_1 = \trainTuple{\square}{1}{*}{[\su{R}{[2,3]}]}$
		\item[] $t_2 = \trainTuple{\vartriangle}{4}{*}{[\su{L}{[2,1]}]}$
	\end{itemize}
	\vspace{0.3cm}
	$R~: \langle J,W,E \rangle$ avec,	
	\begin{itemize}
		\item[] $E = \langle g_1, g_2 \rangle$
		\item[] $J = [0,0,0,0]$
		\item[] $W = \{\langle \bid{1}, \bid{1}, 1, \trainFmt{\square} \rangle, \langle \bid{4}, \bid{4}, 1, \trainFmt{\triangle} \rangle\}$
	\end{itemize}
	\vspace{0.3cm}
	$\swFmt{\sigma} : [d]$
	\vspace{0.3cm}
	\\$F : [(\posFmt{1},\dirForward) : \sigred,(\posFmt{4},\dirBackward) : \sigred]$ \commentaire{// De base, tous les feux sont au vert}
	\vspace{0.3cm}

	$g_1 = [[\incr{1}],[],[\turnOrder{5}{v}, \incr{2}]]$
	\\$g_2 = [[ \incr{4}, \wait{2}{1}],[],[]]$
\end{example}

\paragraph{Dynamique.}
La séparation des feux de signalisation et du régulateur a permis un développement des comportements "fail-safe", voyons comment cela se traduit dans les règles.


\begin{mathpar}
	\inferrule*[left=\ruleDef{SignalSfty}] {
		\signals^\prime = \updateSfty{W}{E}{\trainSeq}{\switches}
	}{
		\redTuple{\guardS}{\bufTrain}{\emptyList}{\stateTuple{\trainSeq}{\regTuple{E}{T}{W}}{\switches}{\signals}}
		\\\reduces
		\redTuple{\guardT}{\bufTrain}{\emptyList}{\stateTuple{\trainSeq}{\regTuple{E}{T}{W}}{\switches}{\signals^\prime}}
	}
\end{mathpar}


\noindent
Le comportement "fail-safe" est géré par la fonction \updateSfty{W}{E}{\trainSeq}{\switches}, qui met à jour l'état de tous les feux en fonction des règles "fail-safe" vues précédemment. La règle \ruleDef{SignalSfty} est la seule à pouvoir réinitialiser l'état de la garde à \guardT, ce qui veut dire que le modèle est contraint d'appliquer le comportement "fail-safe" pour pouvoir effectuer un autre déplacement de train ou débuter un évènement.

\subparagraph{}
La seconde règle \ruleDef{SignalReq} permet au régulateur d'intéragir avec les feux, c'est cette règle qui traite les requêtes de changement d'état des feux.

\begin{mathpar}
	\inferrule*[left=\ruleDef{SignalReq}]{
		\head{\bufSig} = \tuple{\bid{i}, c}
	}{
		\redTuple{\guardS}{\bufTrain}{\bufSig}{\stateTuple{\trainSeq}{R}{\switches}{\signals}}
		\reduces
		\redTuple{\guardS}{\bufTrain}{\buftail{\bufSig}}{\stateTuple{\trainSeq}{R}{\switches}{\setSignalsTo{\bid{i}}{c}}}
	}
\end{mathpar}

\noindent
On remarque que la finalité de cette règle est de dépiler les requêtes, avec \buftail{\bufSig}, mais surtout de changer la signalisation d'un canton, \setSignalsTo{\bid{i}}{c}. Cette dernière met les feux du canton i à l'état c, avec c $\in \{\sigred, \siggreen\}$.

Si on se penche sur les conditions d'utilisation de cette règle, on remarque que la garde doit être dans l'état \guardS et que le buffer relatif aux feux ne doit pas être vide, \head{\bufSig} est défini. 
\paragraph{Limitations.}
Ce modèle parvient à dépasser les limites du modèle précédent en offrant une représentation plus fidèle avec d'un coté les méta-données et de l'autre l'état réel du système.
De plus, nous avons mis au point un système de sécurité limitant les accidents grâce aux comportements "fail-safe" des feux de signalisation. Cependant, des problèmes subsistent, d'une part, les trains n'empruntent pas les aiguillages mais ils se téléportent de canton en canton, ce qui n'est pas réaliste.
D'autre part, les gestionnaires d'évènements sont indexés sur les trains, ce qui n'a aucune cohérence avec la réalité du système~: sur la maquette, un évènement est déclenché par un capteur à l'extrémité du canton.

En plus de ces problèmes, nous avons rencontré un cas plutôt difficile à modéliser avec nos outils actuels~:
\begin{example}[Cycle]
	~\\

	Soit un train se déplaçant sur la maquette, voir figure \ref{fig:grapheMaquette}. Ce train se déplace de manière cyclique sur les cantons 3,4,5,7 puis s'arrête en 6, on a donc un trajet équivalent à celui-ci~: 3,4,5,7,3,4,\dots,3,4,6.
	Au niveau des évènements, le régulateur devra tourner l'aiguillage 13 à un moment précis pour dévier le train et le faire sortir de la boucle, l'ordre \texttt{turn} s'accompagne donc de \texttt{auth}.
	Cependant, lorsque le train démarre grâce à la règle \ruleDef{IncrAfter}, cette dernière, via \nextWait{~}, va chercher le canton où se produit le prochain ordre \texttt{wait} ou \texttt{auth}, le canton 4. Les feux de ce canton passent donc au rouge, c'est un problème majeur car notre train se retrouve bloqué à son premier passage en 4, au lieu de son n-ème passage.
\end{example}











\section{Modèle final}

\paragraph{Raffinement.} À travers ce dernier modèle on se rapproche des comportements réels sur le déplacement des trains, mais aussi sur la gestion d'évènements et d'envoi de messages.
Nous allons introduire des capteurs aux extrémités des cantons afin de détecter le passage des trains, ainsi ce n'est plus le train qui enverra le message mais le capteur, renforçant la séparation entre les différents composants du système.
Une nouvelle fonction, \tsuc{b_i}{d}{\swFmt{\sigma}}, similaire à \suc{b_i}{d}{\sigma}, fait son apparition. Elle est utilisée en parallèle de \texttt{suc} pour déterminer le prochain élément sur lequel se déplacer, que ce soit un canton ou un aiguillage. Pour rappel, \suc{b_i}{d}{\sigma} ne renvoie que le prochain canton.
Enfin, un nouvel ordre pour le programme des trains est introduit afin de régler le problème de cycle évoqué plus haut.

\paragraph{Problématiques.} Ces améliorations entraînent quelques problèmes, notamment un besoin de refonte des gestionnaires d'évènements, dont la structure n'est plus alignée avec le comportement souhaité. \todoMV{Pertinant mais pas clair}

\paragraph{Capteurs.} Ce modèle signe l'arrivée des capteurs dans le système, cependant, il n'existe pas d'objets les modélisant mais ces derniers sont abstraits dans la nouvelle structure des gestionnaires d'évènements et dans les règles de transitions.
Les capteurs se placent derrière les feux de signalisation, de manière à être déclenchés si un train rentre ou sort d'un canton, les aiguillages en sont dépourvus, ne pouvant déclencher d'évènements. Les messages changent de contenu~: $(\bid{i},\dirFmt{d})$, ce format permet d'identifier le capteur ayant envoyé le message.

\paragraph{Trains.} Pour les trains, un cinquième attribut est ajouté à l'état des trains, c'est la position réelle, noté $tpos$, elle permet de prendre en valeur des identifiants d'aiguillage, ce que $pos$ ne peut pas faire.
La position $pos$ représente le dernier canton visité, nous ne pouvons pas nous permettre de perdre cette information car elle est vitale pour le bon fonctionnement des feux de signalisation. Si un train est en transit entre deux cantons, nous voulons que les feux le considèrent toujours comme étant dans le canton d'origine pour éviter qu'un autre train entre dans l'aiguillage et ne provoque un accident.

Aussi, l'ordre \texttt{sync} fait son apparition, il est utilisé comme barrière de synchronisation entre un train et le régulateur, de manière à ce qu'un train ne puisse pas prendre trop d'avance par rapport au régulateur, particulièrement utile pour le poblème de cycle évoquer plus haut. Cet ordre ne peut être dépiler que par le régulateur, simulant une autorisation explicite sans avoir besoin des feux de signalisation.
Son utilisation reste circonstancielle.

\begin{sidebox}
		La modification précédente impacte peu la grammaire du programme des trains~:
	\vspace{0.3cm}\\
	\begin{grammar}
		\firstcasesubtil{T}{\dots}{inchangée}
		\firstcasesubtil{seq}{StartUntil(D,N) \gralt Sync}{}
		\firstcasesubtil{D}{\dots}{inchangée}
		\firstcasesubtil{N}{\dots}{inchangée}
	\end{grammar}
\end{sidebox}

\paragraph{Évènements.} Comme vu plus haut, les gestionnaires d'évènements ne sont plus indéxés sur les trains mais sur les capteurs. Cela implique que les évènements sont donc liés à un capteur, et non plus à un train. Pour être sur d'avoir compris, comparons le domaine de définition de l'ancien modèle, $\trainFmt{\gamma}$, avec le nouveau, $\mathcal{\posFmt{B}} \times \{\dirForward, \dirBackward\}$. Dans les anciens modèles, les évènements étaient stockés en fonction du train ayant déclenché l'évènement, maintenant c'est l'identifiant du capteur.
Cela entraîne un problème majeur, on ne peut plus lier les évènements aux trains, or, nous en avons besoin pour la fonction \texttt{nextWait}, nous verrons comment y remédier plus loin.

De plus la structure des évènements changent aussi, l'information du canton lié à l'évènement en cours est déjà présente dans le message~: les évènements sont, de nouveau, des listes d'ordres uniquement. 


\paragraph{Régulateur.} Nous avons besoin d'introduire des checkpoints pour les trains, notés $CP$. Ils permettent de compenser la perte d'information causée par le changement de domaine des gestionnaires d'évènements. Il est défini par $CP~:~\trainFmt{\gamma} \mapsto \mathcal{L}$, avec $\mathcal{L}$ une liste de cantons. Ainsi, le premier élément de la liste pour un train \tid{i} est le prochain canton où il devra s'arrêter.

\begin{wrapfigure}{r}{0.3\textwidth}
	\centering
	\resizebox{0.3\textwidth}{!}{
		\begin{tikzpicture}[
			vertex/.style={circle, draw=gray, fill=white, very thick, minimum size=7mm, text width=0.5cm, align=center},
		]

		\node[vertex] (t)	  								  {\guardT};
		\node[vertex] (s)  [right=2cm of t]   		  		  {\guardS};
		\node[vertex] (m)  [below right=1cm and 1cm of t]	  {\guardM};
		\node[vertex] (r)  [below=of m]	  {\guardR};


		\draw[->] (t) -- (m);
		\draw[->] (t)  .. controls (1.5,-0.2) ..  (s);
		\draw[->] (m) -- (s);
		\draw[->] (s) .. controls (1.5,0.2) .. (t);
		\draw[->] (m) .. controls (1.25,-2.75) .. (r);
		\draw[->] (r) .. controls (2,-2.75) .. (m);
		\draw[->] (0,0.7) -- (t);


		\end{tikzpicture}
	}
	\caption{Différentes phases du système}
	\label{fig:PhasesM3}
\end{wrapfigure}


Avec les récentes modifications, il est devenu impossible de lier un évènement à un train, ce qui est problématique pour la mise en file d'attente ou encore pour dépiler les checkpoints. Afin de remédier à cela, nous introduisons un historique, noté $H$, défini par $H~:~\trainFmt{\gamma} \mapsto \mathcal{B} \times \{\dirForward, \dirBackward\} $. Associé à ça, on retrouve une fonction \texttt{stalk}($H$,$\swFmt{\sigma}$,msg) qui permet de mettre à jour la position des trains dans $H$ selon le capteur déclenché.
Aussi, lorsque le régulateur commence à traiter des évènements, il le fait jusqu'à ce le buffer soit vide.


\paragraph{Garde.} La garde est toujours présente et se voit dotée d'une nouvelle phase, notée $M$ pour \textit{management}, elle permet au régulateur d'appliquer la fonction \texttt{stalk} avant chaque évènement et de retirer les ordres "sync" dans les programmes des trains.

\begin{example}[GoodEnding M3]
		~\\
	Modélisation de l'état initale d'un scénario en utilisant le modèle 3~:
	\\$G~: T$
	\vspace{0.3cm}
	\\$B_t~: []$ \commentaire{// vide}
	\vspace{0.3cm}
	\\$B_s~: []$ \commentaire{// vide}
	\vspace{0.3cm}
	\\$\trainFmt{\Gamma}~: \{t_1, t_2\}$ avec,
	\begin{itemize}
		\item[] $t_1 = \trainTupleMF{\square}{1}{*}{[\su{R}{[2,3]}]}{1}$
		\item[] $t_2 = \trainTupleMF{\vartriangle}{4}{*}{[\su{L}{[2,1]}]}{4}$
	\end{itemize}
	\vspace{0.3cm}
	$R~: \langle J,W,E,H,CP \rangle$ avec,	
	\begin{itemize}
		\item[] $E = [\dots,(3,\dirBackward)~:~[\turnOrder{5}{v}, \incr{2}], (4,\dirBackward)~:~[\wait{2}{1}],\dots]$
		\item[] $J = [0,0,0,0]$
		\item[] $W = \{\langle \bid{1}, \bid{1}, 1, \trainFmt{\square} \rangle, \langle \bid{4}, \bid{4}, 1, \trainFmt{\triangle} \rangle\}$
		\item[] $H = [\langle \bid{1}, \dirForward \rangle, \langle \bid{4}, \dirBackward \rangle]$
		\item[] $CP = [[-1],[4,-1]]$
	\end{itemize}
	\vspace{0.3cm}
	$\swFmt{\sigma} : [d]$
	\vspace{0.3cm}
	\\$F : [(\posFmt{3},\dirForward) : \sigred,(\posFmt{4},\dirBackward) : \sigred]$ \commentaire{// De base, tous les feux sont au vert}
\end{example}

\paragraph{Dynamique.}

De nouvelles règles concernant les déplacements de trains sont introduites dans ce modèle, en accord avec les objectifs évoqués plus haut. La règle \ruleDef{Until} change peu, on utilise maintenant la fonction \texttt{tsuc} plutôt que \texttt{suc}. De cette manière, on peut savoir si le successeur est un canton où non.

\begin{warnbox}
	Le modèle présenté est en cours de développement, les règles de transitions, implémentées en \TLA, n'ont pas encore fait l'objet d'une formalisation sur papier.
\end{warnbox}


La règle \ruleDef{ExitBlock} permet à un train de sortir d'un canton pour se rendre sur un aiguillage.

\begin{mathpar}
	\inferrule*[left=\ruleDef{ExitBlock}] {
		\tsuc{\bid{i}}{d}{\switches} = \bid{j} \neq \nosuc
		\and
		\texttt{aig(\bid{i})} = true
		\and
		\signalF{\bid{i}}{d} = \siggreen
	}{
		\redTuple{\guardT}{\bufTrain}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{i}}{d}{\trainConcat{\su{d}{\posFmt{N}}}{P}}{\bid{i}}\}}{\regulator}{\switches}{\signals}} \\
		\reduces		
		\redTuple{\guardS}{\push{\bufTrain}{\langle\bid{i},\dirFmt{d}\rangle}}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{i}}{d}{\trainConcat{\su{d}{\posFmt{N}}}{P}}{\bid{j}}\}}{\regulator}{\switches}{\signals}}
	}
\end{mathpar}

\begin{figure}[h]
	\centering
	\resizebox{1\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[red!80!black] (0.5,0.25) circle (1.25mm);
		\fill[green!50!black] (2.5,0.25) circle (1.25mm);
		\fill[red] (1.25,0.25) rectangle (1.75,0.75);

		%aiguillage
		\draw[color=blue] (3.5,0) -- (6.5,0) node[midway,below] {4};
		\draw[color=blue] (5,0) -- (6.5,1) node[midway,below] {};


		\draw (7,0) -- (10,0) node[midway,below] {2};
		\fill[green!50!black] (7.5,0.25) circle (1.25mm);
		\fill[red!80!black] (9.5,0.25) circle (1.25mm);

		\draw (7,1) -- (10,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (7.5,1.25) circle (1.25mm);
		\fill[red!80!black] (9.5,1.25) circle (1.25mm);

		\draw[->] (11,0.5) -- (12,0.5) node[midway,above] {\ruleDef{ExitBlock}};

		\draw (13,0) -- (16,0) node[midway,below] {1};
		\fill[red!80!black] (13.5,0.25) circle (1.25mm);
		\fill[green!50!black] (15.5,0.25) circle (1.25mm);
		\draw[red,dotted] (14.25,0.25) rectangle (14.75,0.75);

		%aiguillage
		\draw[color=blue] (16.5,0) -- (19.5,0) node[midway,below] {4};
		\draw[color=blue] (18,0) -- (19.5,1) node[midway,below] {};
		\fill[red] (17.25,0.25) rectangle (17.75,0.75);


		\draw (20,0) -- (23,0) node[midway,below] {2};
		\fill[green!50!black] (20.5,0.25) circle (1.25mm);
		\fill[red!80!black] (22.5,0.25) circle (1.25mm);

		\draw (20,1) -- (23,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (20.5,1.25) circle (1.25mm);
		\fill[red!80!black] (22.5,1.25) circle (1.25mm);

		\end{tikzpicture}
	}
	\caption{Règle ExitBlock. En bleu, un aiguillage. En pointillé, la position du train selon le régulateur.}
	\label{fig:exExitBlock}
\end{figure}

\noindent
Ici, on remarque que la $tpos$ du train est mise à jour, passant de \bid{i} à \bid{j}, mais que la position $pos$ reste inchangée~: aux yeux du système, le train \tid{m} est toujours dans le canton \bid{i}. On remarque également une nouvelle condition, $\texttt{aig(\bid{i})} = true$, qui nous assure que le successeur est bien un aiguillage.
Intéressons-nous maintenant au passage d'un train d'un aiguillage à un autre.

\begin{mathpar}
	\inferrule*[left=\ruleDef{EnterSwitch}] {
		\tsuc{\bid{i}}{d}{\switches} = \bid{j} \neq \nosuc
		\and
		\texttt{aig(\bid{i})} = true
		\and
		\texttt{aig(\bid{j})} = true
	}{
		\redTuple{\guardT}{\bufTrain}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{c}}{d}{\trainConcat{\su{d}{\posFmt{N}}}{P}}{\bid{i}}\}}{\regulator}{\switches}{\signals}} \\
		\reduces		
		\redTuple{\guardS}{\bufTrain}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{c}}{d}{\trainConcat{\su{d}{\posFmt{N}}}{P}}{\bid{j}}\}}{\regulator}{\switches}{\signals}}
	}
\end{mathpar}

\begin{figure}[h]
	\centering
	\resizebox{1\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[green!50!black] (2.5,0.25) circle (1.25mm);

		%aiguillages
		\draw[color=blue] (3.5,0) -- (6.5,0) node[midway,below] {5};
		\draw[color=blue] (4.5,0) -- (5.2,0.5) node[midway,below] {};
		\draw[color=blue] (5.25,0.55) -- (6,1) -- (6.5,1) node[midway,below] {};
		\draw[color=blue] (6,1) -- (7.5,2) node[pos=0,above] {6};
		\fill[red] (4.25,0.25) rectangle (4.75,0.75);


		\draw (7,0) -- (10,0) node[midway,below] {2};
		\fill[green!50!black] (7.5,0.25) circle (1.25mm);
		\fill[red!80!black] (9.5,0.25) circle (1.25mm);

		\draw (7,1) -- (10,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (7.5,1.25) circle (1.25mm);
		\fill[red!80!black] (9.5,1.25) circle (1.25mm);

		\draw (8,2) -- (10,2) node[pos=0.7,below] {4};
		\fill[green!50!black] (8.5,2.25) circle (1.25mm);
		\fill[red!80!black] (9.5,2.25) circle (1.25mm);

		\draw[->] (11,0.5) -- (12,0.5) node[midway,above] {\ruleDef{EnterSwitch}};

		\draw (13,0) -- (16,0) node[midway,below] {1};
		\fill[red!80!black] (13.5,0.25) circle (1.25mm);
		\fill[green!50!black] (15.5,0.25) circle (1.25mm);

		%aiguillages
		\draw[color=blue] (16.5,0) -- (19.5,0) node[midway,below] {5};
		\draw[color=blue] (17.5,0) -- (18.2,0.5) ;
		\draw[color=blue] (18.25,0.55) -- (19,1) -- (19.5,1) node[pos=0,below] {6};
		\draw[color=blue] (19,1) -- (20.5,2);
		\fill[red] (18.5,1.25) rectangle (19,1.75);


		\draw (20,0) -- (23,0) node[midway,below] {2};
		\fill[green!50!black] (20.5,0.25) circle (1.25mm);
		\fill[red!80!black] (22.5,0.25) circle (1.25mm);

		\draw (20,1) -- (23,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (20.5,1.25) circle (1.25mm);
		\fill[red!80!black] (22.5,1.25) circle (1.25mm);

		\draw (21,2) -- (23,2) node[pos=0.7,below] {4};
		\fill[green!50!black] (21.5,2.25) circle (1.25mm);
		\fill[red!80!black] (22.5,2.25) circle (1.25mm);

		\end{tikzpicture}
	}
	\caption{Règle EnterSwitch.}
	\label{fig:exEnterSwitch}
\end{figure}

La règle \ruleDef{EnterSwitch} est prèsque similaire à la précédente. Tout d'abord, on note la disparition de la contrainte sur le feu et de l'envoi de message, le train se trouvant sur un aiguillages, aucun feu de signalisation ou capteur ne sont présents.
Enfin, pour utiliser cette règle nous avons besoin que le train se trouve sur un aiguillage, d'où la contrainte $\texttt{aig(\bid{i})} = true$. Dernière règle de cette section, nous allons voir comment un train passe d'un aiguillage à un canton. \todo{figure mal placé}

\begin{mathpar}
	\inferrule*[left=\ruleDef{ExitBlock}] {
		\tsuc{\bid{i}}{d}{\switches} = \bid{j} \neq \nosuc
		\and
		\texttt{aig(\bid{i})} = true
		\and
		\texttt{aig(\bid{j})} = false
		\\
		\posFmt{N} = \bid{j} \cdot \posFmt{N'}
		\and
		\posFmt{N'} \neq \emptyList
	}{
		\redTuple{\guardT}{\bufTrain}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{a}}{d}{\trainConcat{\su{d}{\posFmt{N}}}{P}}{\bid{i}}\}}{\regulator}{\switches}{\signals}} \\
		\reduces		
		\redTuple{\guardS}{\push{\bufTrain}{\langle\bid{j},\dirFmt{d^{-1}}\rangle}}{\bufSig}{\stateTuple{\trainSeq{}\cup\{\trainTupleMF{\tid{m}}{\bid{j}}{d}{\trainConcat{\su{d}{\posFmt{N^\prime}}}{P}}{\bid{j}}\}}{\regulator}{\switches}{\signals}}
	}
\end{mathpar}

\begin{figure}[h]
	\centering
	\resizebox{1\textwidth}{!}{
		\begin{tikzpicture}[thick,scale=1]
		\draw (0,0) -- (3,0) node[midway,below] {1};
		\fill[green!50!black] (2.5,0.25) circle (1.25mm);
		\draw[red,dotted] (1.25,0.25) rectangle (1.75,0.75);

		\draw[color=blue] (3.5,0) -- (6.5,0) node[midway,below] {4};
		\draw[color=blue] (5,0) -- (6.5,1) node[midway,below] {};
		\fill[red] (4.25,0.25) rectangle (4.75,0.75);


		\draw (7,0) -- (10,0) node[midway,below] {2};
		\fill[green!50!black] (7.5,0.25) circle (1.25mm);
		\fill[red!80!black] (9.5,0.25) circle (1.25mm);

		\draw (7,1) -- (10,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (7.5,1.25) circle (1.25mm);
		\fill[red!80!black] (9.5,1.25) circle (1.25mm);

		\draw[->] (11,0.5) -- (12,0.5) node[midway,above] {\ruleDef{ExitBlock}};

		\draw (13,0) -- (16,0) node[midway,below] {1};
		\fill[red!80!black] (13.5,0.25) circle (1.25mm);
		\fill[green!50!black] (15.5,0.25) circle (1.25mm);

		\draw[color=blue] (16.5,0) -- (19.5,0) node[midway,below] {4};
		\draw[color=blue] (18,0) -- (19.5,1);


		\draw (20,0) -- (23,0) node[midway,below] {2};
		\fill[green!50!black] (20.5,0.25) circle (1.25mm);
		\fill[red!80!black] (22.5,0.25) circle (1.25mm);
		\fill[red!80!black] (0.5,0.25) circle (1.25mm);
		\fill[red] (21.25,1.25) rectangle (21.75,1.75);




		\draw (20,1) -- (23,1) node[pos=0.7,below] {3};
		\fill[green!50!black] (20.5,1.25) circle (1.25mm);
		\fill[red!80!black] (22.5,1.25) circle (1.25mm);

		\end{tikzpicture}
	}
	\caption{Règle EnterBlock.}
	\label{fig:exEnterBlock}
\end{figure}

\noindent
Cette règle "signe" la re-synchronisation du train avec le reste du système, on observe que $pos$ est égale à $tpos$. C'est aussi le retour de l'envoi de message, le train se trouvant dans un canton, il a donc franchit le capteur de début de canton, $\langle\bid{j},\dirFmt{d^{-1}}\rangle$. 

\paragraph{Limitations.} Bien que ce modèle soit le plus proche de la réalité, il se place dans un environnement hostile puisque nous n'imposons pas de garantie sur le délai de traitement des messages. Hors, dans la réalité, le traitement des informations et bien plus rapide que le déplacement des trains, beaucoup de mécanisme présent dans ce modèle n'ont donc pas lieu d'être.
Cependant, pour prouver cela, il faut se tourner vers les automates temporisés. Nous n'avons pas eu le temps de nous pencher sur ce sujet.













\chapter{Implémentation}
\label{sec:implem}

\section{TLA+}
\label{sec:tla}

\begin{wrapfigure}{r}{0.4\textwidth}
	\centering
	\includegraphics[width=\linewidth]{graph_ge0.jpg}
	\caption{Espace d'état de GoodEnding sur le modèle zéro}
	\label{fig:espaceEtat}
\end{wrapfigure}


\paragraph{Introduction.} \TLA est un language de spécification formelle développé par Leslie Lamport \todo{citation}, très populaire au sein de la communauté des systèmes distribués. Il est principalement utilisé pour faire de vérification de programmes, c'est-à-dire prouver que le programme respecte certaines propriétés.
Dans notre cas, nous allons beaucoup utiliser un outil présent dans \TLA, le model checker \textit{TLC}, qui permet d'explorer l'espace d'état d'une spécification. Autrement dit, il permet de générer tous les états d'un système si celui-ci est fini, ainsi il est possible de vérifier si nos propriétés sont toujours respectées.
Nous avons choisi d'utiliser cet outil car il est facile de représenter une machine à états finis, ce à quoi s'apparente notre système.

\paragraph{Spécification.} Les spécifications \TLA telles que nous allons les utiliser comportent plusieurs éléments clés, comme des variables, des propriétés temporelles et des actions, nous verrons cela plus en détail par la suite.
Ces éléments doivent être rédigées en utilisant la syntaxe formelle de l'outil, qui repose grandement sur des expressions mathématiques et logiques. Ce langage n'est pas un langague de programmation, il n'est pas possible d'écrire de boucle et les structures de données sont "limitées", mais il est quand même possible de définir des fonctions. 
De plus, le programme s'exécute de manière non déterministe, étape par étape, en choisissant une action applicable au hasard.

\subparagraph{} Les variables sont centrales, c'est elles qui représentent l'état du système, elles sont les seules données à persister entre les actions. Pour le modèle 0, nous avons trois variables appelées \texttt{gamma}, \texttt{reg} et \texttt{rule}, la dernière étant une mesure de debug pour contrôler quel action à été appliquée.
Nos variables sont initialisées dans une donnée particulière appelée \texttt{init}, cette dernière décrit l'état initial du système.
Au sein des actions, il est possible d'utiliser des "constantes locales", qui ne persistent que pendant l'exécution de l'action. Cependant, il est impossible de redéfinir ces constantes, le comportement est plus proche d'une macro facilitant l'écriture.


\begin{minted}{C}
Init == 
	LET 
		four_to_8 ==  << <<"StartUntil","b",<<3,8>> >>  >>
		five_to_4 ==  << <<"StartUntil","f",<<7,3,4>> >> >>
		train1 == [tid|->1, pid|->4, d|->"*", prog|-> four_to_8]
		train2 == [tid|->2, pid|->5, d|->"*", prog|-> five_to_4]
		traffic_lights ==[x \in (1..8) \X {"f","b"} |-> "g"]
		...
	IN
		/\ gamma = <<train1,train2>>
		/\ sigma =  <<"d", "d", "v", "d", "d">> 
		/\ F = [traffic_lights EXCEPT ![7,"f"]="r", ![8,"b"]="r"]
		...
\end{minted}

\begin{figure}[h]
	\caption{Initialisation des variables dans le modèle 2}
	\label{fig:initTLA}
\end{figure}

Sur la figure \ref{fig:initTLA}, on peut voir une structure, \texttt{train1} représentant un train et associant la chaîne de caractères "tid" à la valeur 1, "pid" à la valeur 4, etc. De cette manière, on peut accéder aux valeurs d'une structure en utilisant les clés appropriées, \texttt{train1.tid} par exemple.


\subparagraph{} Les actions représentent nos règles de transitions, elles permettent de modifier l'état du système sous certaines conditions. Elles ont besoins d'être regroupées sous une même "fonction", appelée \texttt{Next}, qui décrit le comportement du système.

\begin{minted}{C}
Until(T) == 
LET
	numEv == reg.Ne[T.id]
	id == T.id
	event == reg.E[id][numEv]
	order == Head(T.prog)
	nextC == Suiv(T.pos,T.dir, reg.S)
	auth == reg.A[id]
IN
	/\ Len(T.prog) > 0
	/\ Len(event) = 0
	/\ order[2] = T.dir 
	/\ auth /= 0
	/\ order[1] = "StartUntil"
	/\ nextC /= -1
	/\ order[3] /= nextC
	/\ gamma' = [gamma EXCEPT ![id].pos = nextC]
	/\ rule' = "until"
	/\ reg' = [reg EXCEPT !.Ne[id] = numEv+1,
			      !.A[id] = auth-1]
\end{minted}

\begin{figure}[h]
	\caption{Implémentation de la règle Until en \TLA}
	\label{fig:untilTLA}
\end{figure}

Grâce à la figure \ref{fig:untilTLA}, on remarque plusieurs choses intéressantes. Tout d'abord, la syntaxe, les symboles $\wedge$ expriment une conjonction logique, c'est-à-dire que toutes les \textit{clauses} doivent être vraies pour effectuer la transition.
On sépare ces clauses en deux catégories, les conditions nécéssaires à l'action, équivalente à nos prémisses dans les règles, et les clauses modifiant l'état, équivalente à nos conclusions. Ces dernières sont facilement identifiables grâce à l'opérateur prime ($^\prime$), à noté qu'une variable ne subissant pas de modification sera notée \texttt{UNCHANGED}.

\subparagraph{} Enfin, les propriétés temporelles vont déterminer si l'implémentation de notre modèle à le bon comportement. Pour cela, on définit deux propriétés~: \textit{safety} et \textit{liveness}.
La première permet de s'assurer qu'aucune collision n'a lieu, pour cela on veut que tous les trains soit toujours sur des cantons différents. La seconde propriété nous assure du bon fonctionnement du système, on traduit par le fait que tous les trains sont à l'arrêt à leur destination.


\begin{minted}{C}
Safety == [] (gamma[1].pos /= gamma[2].pos)


Liveness == 
    /\  <>[] /\ gamma[1].pos = 3
             /\ gamma[1].dir = "*"
    /\  <>[] /\ gamma[2].pos = 1
             /\ gamma[2].dir = "*"
\end{minted}

\begin{figure}[h]
	\caption{Implémentation des propriétés en \TLA}
	\label{fig:propertiesTLA}
\end{figure}

\noindent
Pour nous aider à formuler ces propriétés, \TLA inclut deux opérateurs temporelles~:
\begin{itemize}
	\item $\Box$ : signifiant "toujours"
	\item $\Diamond$ : signifiant "finalement"
\end{itemize}
\noindent
Ainsi, "$\Box~(gamma[1].pos \neq gamma[2].pos)$" signifie que les positions des trains 1 et 2 sont \textbf{toujours} différentes.
Maintenant, il est possible de combiner ces opérateurs, comme dans "$\Diamond \Box~gamma[1].pos = 3$", ce qui signifie qu'à un moment la position du train 1 sera égale à 3 pour toujours. En reformulant, on obtient~: à un moment le train 1 s'arrêtera sur le canton 3.

\begin{minted}{C}
Spec == Init /\ [][Next]_<<gamma,reg, rule>> /\ WF_<<gamma,reg,rule>>(Next)
\end{minted}

\begin{figure}[h]
	\caption{Spécification}
	\label{fig:specTLA}
\end{figure}

Cette ligne ci-dessus permet de spécifier le comportement de notre modèle. on y retrouve l'état initial, \texttt{Init}, les actions, \texttt{Next}, et un dernier élément encore inconnu, \texttt{WF\_<<gamma,reg,rule>>(Next)}. 

\paragraph{Stuttering.} Le Stuttering est un concept important de \TLA, il donne l'opportunité de modéliser des systèmes où le temps peut s'écouler sans changement d'état. Cependant, ce cas de figure ne nous concerne pas, si une règle de transition peut-être appliquée, alors elle le sera.
Pour indiquer cela à \TLA, nous devons utiliser la \textit{weak fairness}, une condition qui stipule que si une action peut être exécutée, alors elle sera finalement exécutée. Dans la spécification, cette condition est représenté par \texttt{WF\_<<\dots>>(Next)}.



\section{Composition}
\label{sec:composition}

\paragraph{} Jusqu'à présent, nous avons considérer que les programmes des train et du régulateur étaient créer par un humain. Cependant, il est possible d'automatiser ce processus, c'est ce que nous allons voir dans cette section.
Ce besoin est apparu lors de phases de test où il était nécessaire d'avoir plusieurs trajets avec des aspects différents pour vérifier que le comportement du système était correct.

\paragraph{}Nous avons d'abord identifier deux types de trajets~:
\begin{itemize}
	\item Les chemins élémentaires, où chaque paire de trains ne possède pas de ressources critiques.
	\item Les chemins non-élémentaires, où au moins une paire de trains partage une ressource.
\end{itemize}
En regardant les chemins non-élémentaires, on remarque qu'il est toujours possible de les décomposer en deux chemins $c_1 \cdot c_2$, tel que $c_1$ ou $c_2$ est un chemin élémentaire.

\begin{example}
	Soit un chemin non-élémentaire $c$ dont les trains \tid{a} et \tid{b} partagent une ressource critique $crit$ et dont les cantons parcouru sont respectivement $P_a = [a,crit,a^\prime]$ et $ P_b = [b,crit,b^\prime]$; avec $a,a^\prime,b,b^\prime$ des liste de cantons.

	Il existe un couple de chemin dont au moins l'un est élémentaire~: $c_0$ avec $P_a = [a,crit,a^\prime]$ et $P_b = []$, $c_0^\prime$ avec $P_a = []$ et $P_b = [b,crit,b^\prime]$.

	Ainsi, on peut décomposer le chemin non-élémentaire $c$ en deux chemins $c_0$ et $c_0^\prime$, dont au moins l'un est élémentaire.
\end{example}

Nous avons donc réussi à élaborer une fonction de composition $C(c_1,c_2)$ avec $c_1$ un chemin élémentaire ou issue d'une composition, et $c_2$ un chemin élémentaire. Ainsi, si l'on veut composer un trajet $T$ de quatres chemins élémentaires, on peut faire~: $T=C(C(C(c_1,c_2),c_3),c_4)$.
\todo[inline]{inclure lien vers archive zenodo, version plus ancienne est pas très propre du code}

\section{Expériences}
\label{sec:experiences}

\paragraph{}
Dans le but de tester notre fonction de composition, nous avons dévéloppé un ensemble de scripts Python pour automatiser la création et la vérification de chemins composés.
On définit un couple de chemins comme étant composable si les positions d'arrivée du premier chemin sont les positions de départ du second. Le flux opérationnel est le suivant~:
\begin{itemize}
	\item Création de chemins élémentaires à partir d'un dictionnaire, \texttt{safe\_steps.json}, réalisé en amont.
	\item Composition des chemins élémentaires en utilisant notre fonction $C(c_1,c_2)$.
	\item Transcription du chemin composé dans un fichier \texttt{compo.tla}.
	\item Model checking avec tlc sur \texttt{compo.tla} et \texttt{model.tla}.
	\item Logging des résultats dans \texttt{out.log} et \texttt{errors.log}.
\end{itemize}

\begin{figure}[h]
	\begin{tikzpicture}
		\tikzstyle{programme} = [
		draw=black,
		]
		\tikzstyle{fichier} = [
		rounded corners,
		draw=blue,
		]
		\tikzstyle{generated} = [
		fill=blue!10,
		]
		\node[programme] (main) {main.py};
		\node[fichier, below=of main] (json) {safe\_steps.json};
		\node[programme, right = of main] (compose) {compose.py};
		\node[programme, right=of compose] (to_tla) {to\_tla.py};
		\node[fichier, below=of to_tla, generated] (compo) {route.tla};
		\node[programme, right=1.5cmof compo] (tlc) {tlc};
		\node[fichier, above=of tlc] (model){model.tla};	
		\node[fichier, above right=of tlc, generated] (out) {out.log};
		\node[fichier, right=1.5cm of tlc, generated] (err) {errors.log};
		
		\draw[stealth-] (json) to node[sloped, anchor=south] {uses} (main);
		\draw[-stealth] (main) to node[sloped, anchor=south] {calls} (compose);
		\draw[-stealth] (main) to[bend right] node[sloped, anchor=south] {calls} (to_tla);
		\draw[-stealth] (to_tla) to node[anchor=west] {creates} (compo);
		\draw[-stealth] (tlc) to node[sloped, anchor=south] {reads} (compo);
		\draw[-stealth] (tlc) to node[sloped, anchor=south] {reads} (model);
		\draw[-stealth] (tlc) to node[sloped, anchor=north] {creates} (err);
		\draw[-stealth] (tlc) to node[sloped, anchor=south] {creates} (out);
	\end{tikzpicture}
	\caption{Workflow des tests. Les rectangles noires sont des programmes. Les rectangles bleus arrondis sont des fichiers, y compris les fichiers générés remplis en bleu.}
	\label{fig:toolchain}
\end{figure}

Le workflow décrit plus haut peut être décliné pour tester des trajets composés de plusieurs chemins élémentaires. Dans notre cas, nous avons testé sur des trajets de 2 et 3 chemins.

\paragraph{Résultats.} 
Ces expériences ont été conduites sur Grid'5000,\todo{citation} un banc d'essai dédié à la recherche expérimentale. La majorité des tests ont été effectués sur 32 nodes, dotés d'un processeur 18 cœurs, de la machine "Gros" du cluster de Nancy.
Voici les résultats~:

\begin{center}
	Modèle 2 :
\begin{tabular}{|c|c|c|c|c|}
	\hline
	Nombre de chemins & Temps d'exécution (h) & Succès & Échecs\\
	\hline
	2 & 20,7 & 381072 & 0 \\
	\hline
	3 & 0,6  & 10791 & 91 \\
	\hline
\end{tabular}
\end{center}

\begin{center}
	Modèle final :
\begin{tabular}{|c|c|c|c|c|}
	\hline
	Nombre de chemins & Temps d'exécution (h) & Succès & Échecs\\
	\hline
	2 & 35,8 & 381072 & 0 \\
	\hline
	3 & X  & X & X \\
	\hline
\end{tabular}
\end{center}

On observe que les compositions de deux chemins élémentaires se déroule sans problème pour nos deux modèles \footnote{Les expériences n'ont été menées que sur le modèles 2 et le modèle final car ce sont les seuls à être doté d'une fonction de composition.} avec 0 erreur à signaler.
La différence de temps d'exécution entre les deux modèles s'explique par la complexité croissante des modèles, mais également de la fonction de composition l'accompagnant.

Pour la composition à trois chemins, nous avons mené l'expériences sur un échantillon réduit pour avoir une intuition sur les performances de la fonction de composition. Ces tests avaient été mené dans le cadre de l'écriture d'une article, la deadline étant courte, nous n'avions pas assez de temps pour tester sur tous les cas possibles.
Les 91 cas menant à une erreur ont été vérifiés manuellement sur une machine personelle et n'ont produit aucune erreur, nous suspectons un léger problème dans l'environnement de test (un fichier qui n'est pas à jour, une version obsolète, etc).  
Pour le modèle final, nous n'avons pas eu le temps de mener les tests à trois chemins.




\chapter{Side Quests}
\label{sec:sidequests}

\paragraph{Maquette.} Une fois les principaux objectifs atteints, nous avons pu nous pencher sur des problèmes secondaires, coomme la création d'une "maquette de la maquette".
Cela permet de construire un prototype se basant sur une architecture différente de celle actuellement utilisée, afin de moderniser la maquette.

\begin{figure}[h]
	\centering
	\resizebox{0.5\textwidth}{!}{
	\begin{tikzpicture}
		\tikzstyle{feu} = [
		circle,
		draw=black,
		]
		\tikzstyle{machine} = [
		rounded corners,
		draw=blue,
		minimum height=3cm,
		]
		\tikzstyle{aig} = [
		draw=black,
		fill=black!10!white,
		]
	
		\node[machine] (rasp) {Raspberry Pi};
		\node[machine] (ard) [above=3cm of rasp] {Arduino};
		%\node[machine] (ard2) [left=3cm of rasp] {Arduino};
		
		\node[feu] (f1) [above right=0.5cm and 3cm of ard] {Feu 1};
		\node[feu] (f2) [below right=0.5cm and 3cm of ard] {Feu 2};
		\node[aig] (a1) [below=1.5 of f1] {Aiguillage 1};

		\node[feu] (f3) [above left=0.5cm and 3cm of ard] {Feu 3};
		\node[feu] (f4) [below left=0.5cm and 3cm of ard] {Feu 4};
		\node[aig] (a2) [below=1.5 of f3] {Aiguillage 2};

		\draw[->] (rasp) edge[bend left=0.5cm] node[above,sloped] {I2C} (ard);
		\draw[->] (ard) edge[bend left=0.5cm] node[above,sloped] {I2C} (rasp);
		\draw[-] (ard) -- (f1);
		\draw[-] (ard) -- (f2);
		\draw[-] (ard) -- (a1);
		\draw[-] (ard) -- (f3);
		\draw[-] (ard) -- (f4);
		\draw[-] (ard) -- (a2);

	\end{tikzpicture}
	}
	\caption{Schéma simplifié.}
	\label{fig:prototype}
\end{figure}

Pour communiquer entre le Raspberry Pi et les Arduinos, nous utilisons le protocole I2C, permettant une communication efficace dans un modèle maître-esclave.
En l'état, le raspberry Pi, appelé orchestrateur, coordonne un arduino afin de gérer les feux de signalisation et l'état des aiguillages d'un carrefour représentant les cantons 1, 2 et 3 et leurs aiguillages.
L'orchestrateur interroge toutes les 100ms l'état des capteurs de voie, via l'arduino, afin de savoir si un train a changé de position. Si c'est le cas, alors il calcule les transformations à appliquer au système (feux au rouge, aiguillages à changer, etc.) et les envoie à l'arduino.
Les messages entre les deux machines sont très simples, par exemple~: \texttt{F1r} pour passer le feu 1 au rouge, \texttt{A2v} pour mettre l'aiguillage 2 en position déviée.

%\section{Article}

\paragraph{Article.}
Ce stage à été l'occasion de découvrir le monde de la publication scientifique, en particulier la rédaction d'articles, la soumission et le processus de relecture par les pairs. 
En effet, un article à été rédigé pour partager notre travail sur le modèle 2, sur la fonction de composition et sur les expériences menées. Malgré des délais très courts, ce dernier a été soumis dans les temps à la conférence \texttt{RSSRail 2025}, mais il n'a pas été retenu.
La relecture par les pairs à été une expériences enrichissante, nous avons reçu des retours constructifs qui nous aiderons à améliorer l'article pour une future soumission.








\chapter{Conclusion}

\paragraph{} Ce stage avait pour objectif de créer un outil permettant de vérifier l'ordonnancement de programme de train, voyons si ces objectifs ont été atteints.
Pour cela, nous avons d'abord modélisé la maquette sous forme de graphe, figure \ref{fig:maquette}, afin d'avoir un espace dans lequel faire se déplacer nos trains.
Il a ensuite fallu créer des modèles successifs, chaque fois plus proche de la réalité, en intégrant des éléments comme les capteurs de voie ou les feux de signalisation.
Bien qu'importantes, ces intégrations ont fait émerger des problématiques, aujourd'hui résolues.

\subparagraph{}
Comme il est presque impossible pour un humain de tracer l'ensemble des états d'un système comme celui-ci, nous avons dû implémenter les modèles, d'abord sur Python grâce à un moteur de simulation, puis sur \TLA avec l'assistance de \texttt{TLC}.  
Différents scénarios, dont nous connaissions parfaitement les comportements attendus, ont permis de pointer les diverses erreurs dans nos modèles.

\subparagraph{}
Notre méthode de travail nous a permis de rentrer en douceur dans le sujet, avec un premier modèle naïf, puis de complexifier progressivement les choses. Cette approche itérative est chronophage, mais, elle permet de segmenter des problèmes complexes en sous-problèmes plus simples à résoudre.
Par exemple, sauter directement du modèle zéro au modèle final, en mélangeant le découplage, l'ajout des feux, des capteurs, etc., aurait été une tâche plus complexe. De plus, avec cette méthode, nous avons une connaissance plus fine des différents composants et de leurs interactions dans le système.
Cependant, notre méthodologie à parfois montré des faiblesses, notamment en ce qui concerne les données superflues. Une donnée inutile dans le modèle, vestige du modèle précédent, peut complexifier la compréhension du système. Aussi, de par sa nature itérative, si un problème n'a pas été détecté dans un modèle antérieur, il se propagera sur les suivants.

\subparagraph{}
Nous avons ensuite développé une fonction de composition dans le but d'automatiser la création de programmes pour notre système. Pour nous assurer de sa justesse, nous avons déployé des tests automatisés sur un banc d'essai, lesquels ont donné des résultats encourageants.
Cependant, nos expériences n'ont été réalisées qu'avec des compositions de deux ou trois chemins élémentaires, ce qui ne nous permet pas d'affirmer que notre approche est généralisable à des compositions plus grandes.

\section{POV personnel}

\appendix

\chapter{Annexes}

\backmatter
%\printbibliography
%\bibliographystyle{acm}
%\bibliography{ref}
\printindex


\end{document}


