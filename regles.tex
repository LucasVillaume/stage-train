\documentclass[12pt]{article}
\usepackage{package/formal-grammar}
\usepackage{package/mathpartir}
\usepackage{package/algorithm}
\usepackage{package/algpseudocode}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{graphicx}



\title{Modèle 1}
\author{}

\begin{document}

%%%%% Macro %%%%%%%
\newcommand\concat[2]{#1;#2}
\newcommand\train[6]{(#1, #2, #3, #4, #5, #6)} % #1 id, #2 pos, #3 dir, #4 P, #5 auth, #6 rel
\newcommand\trainfull[6]{\Gamma \cup \train{#1}{#2}{#3}{#4}{#5}{#6}} 
\newcommand\reg[4]{(#1, #2, #3, #4)} % #1 Events, #2 Jetons, #3 Aiguillages, #4 File d'attente
\newcommand\regPP[6]{(#1, #2, #3, #4, #5, #6)} % #1 Events, #2 Jetons, #3 Aiguillages, #4 File d'attente

\newcommand\maj[2]{#1 \gets #2} % #1 : dictionnaire, #2 : valeur
\newcommand\majtab[3]{#1[#2] \gets #3}
\newcommand\supprdict[2]{#1' \gets suppr(#1, #2)} % #1 : dictionnaire, #2 : clé
\newcommand\bracket[2]{
    \begin{math}
        \biggl\{
        \begin{array}{l}
            #1\\
            #2
        \end{array}
    \end{math}
}

\iffalse
\newcommand\ruleStart[3]{ %1 id, 2 pos, 3 D
    \inferrule
    { }
    {\trainfull{#1}{#2}{*}{\concat{Start(#3)}{P'}}, R \Rightarrow \trainfull{#1}{#2}{#3}{P'}, R} 
}

\newcommand\ruleStop[3]{ %1 id, 2 pos, 3 dir
    \inferrule
    { }
    {\trainfull{#1}{#2}{#3}{\concat{Stop()}{P'}}, R \Rightarrow \trainfull{#1}{#2}{*}{P'}, R} 
}

\newcommand\ruleUntil[5]{ %1 id, 2 pos, 3 dir, 4 pos', 5 N
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#5)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{\concat{Until(#5)}{P'}}, R}
}


\newcommand\ruleUntilCons[4]{ %1 id, 2 pos, 3 dir, 4 pos'
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#4)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{P'}, R}
}

\newcommand\ruleUntilEv[5]{ %1 id, 2 pos, 3 dir, 4 pos', 5 N
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2 \\ ev(#1, #4) \in R.E \\ apply(R, ev(#1, #4)) = R'}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#5)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{\concat{Until(#5)}{P'}}, R'}
}

\newcommand\ruleUntilConsEv[4]{ %1 id, 2 pos, 3 dir, 4 pos'
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2 \\ ev(#1, #4) \in R.E \\ apply(R, ev(#1, #4)) = R'}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#4)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{P'}, R'}
}

\newcommand\ruleWait[4]{ %1 id, 2 pos, 3 dir, 4 x,y
    \inferrule
    {R.A[#1] = #2 \\ ev(#1,#2) \in R.E \\ R.E[ev[#1, #2]].P = att(#4)  \\ apply(R, ev(#1, #2)) = R'}
    {\trainfull{#1}{#2}{#3}{P}, R \Rightarrow \trainfull{#1}{#2}{#3}{P}, R'}
}

\newcommand\ruleCrash[2]{ %1 id, 2 id'
    \inferrule
        {#1 \neq #2}
        {\Gamma, \train{#1}{pos}{dir}{P}, \train{#2}{pos}{dir'}{P'}  \Rightarrow \bot}
}

\newcommand\ruleCrashSec[3]{ %1 id, 2 pos, 3 dir
    \inferrule
        {\lnot suiv(#2, #3) = \emptyset \\ #3 \neq * \\ R.A[#1] \neq #2}
        {\trainfull{#1}{#2}{#3}{P}, R \Rightarrow \bot}
}
\fi



\maketitle


\section{Définition}

\subsection{Représentation du train}
Dans notre modèle, un train est représenté par un sextuplet $(id, pos, dir, P, auth, rel)$ où :
\begin{itemize}
    \item $id$ : identifiant du train
    \item $pos$ : position du train 
    \item $dir$ : direction du train
    \item $P$ : programme du train
    \item $auth$ : nombre de transition restantes autorisés
    \item $rel$ : position relative du train par rapport au départ
\end{itemize}

\subsection{Représentation du régulateur}
Le régulateur est représenté par un quadruplet $(E, J, S, W)$ où :
\begin{itemize}
    \item $E$ : événements du régulateur
    \item $J$ : tableau de jetons
    \item $S$ : tableau des aiguillages
    \item $W$ : file d'attente
\end{itemize}


\subsection{Notation}
\iffalse
On note
\\
$\mathbf{O}_{e}$ l'ensemble des ordres des événements
\vspace{0.3cm} \\
dict : $\mathbf{A} \rightarrow \mathbf{B}$ avec $\mathbf{A}$ l'ensemble des clés et $\mathbf{B}$ l'ensemble des valeurs
\\ $\mathbf{A} \times \mathbf{B}$ telque \{ $\langle k,v \rangle$ si $k_{j} \neq k_{i}$ \} \\
\vspace{0.1cm} \\
suppr(D,k) = \bracket{D \backslash \{\langle x,D[x] \rangle\} \text{ si } k = x}{D \text{ sinon}}
\\
\vspace{0.3cm} \\
E : dict avec \bracket{a \in \mathbf{A} | a = \langle id_{t}, numEv \rangle}{\mathbf{B} \subseteq \mathbf{O}_{e}}
\vspace{0.3cm} \\
W : dict avec \bracket{a \in \mathbf{A} | a = \langle id_{c}, val_{j} \rangle}{\mathbf{B} \subseteq \mathbf{N}}
\vspace{0.3cm} \\
Soit un tableau T, on note la mise à jour de T à la position i avec la valeur v par $\majtab{T}{i}{v}$ 
\fi

\subsection{Définition des prédicats et fonctions}

\begin{itemize}
    \item $suiv(pos, dir, switch)$ : renvoi la position suivante 
\end{itemize}

%%%%% Grammaire %%%%%%

\section{Grammaire}



\begin{grammar}[Grammaire des trains][h][train]
    \firstcasesubtil{T}{\concat{seq}{T}}{}
    \otherform{\varepsilon }{}
    \firstcasesubtil{seq}{StartUntil(D,N)}{}
    \firstcasesubtil{D}{L \gralt R}{}
    \firstcasesubtil{N}{0 \gralt 1 \gralt ... }{} 
\end{grammar}

\vspace{0.5cm}

\begin{grammar}[Grammaire du régulateur][h][regulateur]
    \firstcasesubtil{R}{stmt || R}{}
    \otherform{\varepsilon}{}
    \firstcasesubtil{stmt}{ev(id_{train}, num_{event}) : atom}{}
    \firstcasesubtil{atom}{incr(j)}{}
    \otherform{att(j, value_{j})}{}
    \otherform{turn(id_{switch}, state)}{}
    \otherform{atom \gralt \varepsilon}{}

\end{grammar}

%%%%%% Règles %%%%%%

\newpage
\section{Règles}

\subsection{Système}

\inferrule
    {\alpha \xRightarrow{\text{!e}} \alpha' \\ \beta \xRightarrow{\text{?e}} \beta' }
    {\alpha||\beta \Rightarrow \alpha' || \beta' } 
\vspace{0.5cm}

\subsection{Actions sur le train}

Start : 
\inferrule
    { dir \neq D}
    {\trainfull{id}{pos}{dir}{\concat{SU(D,N)}{P'}}{auth}{rel} \\ \xRightarrow{\text{!ev(id,rel)}} \\ \trainfull{id}{pos}{D}{\concat{SU(D,N)}{P'}}{auth}{rel}} 
\vspace{0.5cm}


Stop :
\inferrule
    { P = \varepsilon \\ dir \neq *}
    {\trainfull{id}{pos}{dir}{P}{auth}{rel} \\ \Rightarrow \\ \trainfull{id}{pos}{*}{P}{auth}{rel}}
\vspace{0.5cm}


Until :
    \inferrule
    { suiv(pos, D, S) = pos' \\ pos' \neq N \\ pos' \neq \varepsilon \\ auth \neq 0}
    {\trainfull{id}{pos}{D}{\concat{SU(D,N)}{P'}}{auth}{rel} \\ \xRightarrow{\text{!ev(id,rel+1)}} \\ \trainfull{id}{pos'}{D}{\concat{SU(D,N)}{P'}}{auth-1}{rel+1}}
\vspace{0.5cm}


Until$_{cons}$ :
    \inferrule
        { suiv(pos, D, S) = pos' \\ auth \neq 0 \\ rel = x}
        {\trainfull{id}{pos}{D}{\concat{SU(D,pos')}{P'}}{auth}{rel}\\ \xRightarrow{\text{!ev(id,rel+1)}} \\ \trainfull{id}{pos'}{D}{P'}{auth-1}{rel+1}}
\vspace{0.5cm}

Recv :
    \inferrule
        { }
        {\trainfull{id}{pos}{D}{P}{auth}{rel}\\ \xRightarrow{\text{?(id,suppl)}} \\ \trainfull{id}{pos}{D}{P}{auth+suppl}{rel}}
\vspace{0.5cm}

\newpage

\subsection{Actions sur le régulateur}

\subsubsection{Approche grands pas}

Pour cette approche, on ajoute au régulateur un buffer d'événements $B_E$ qui contient les événements en 
attente d'être traités
\vspace{0.5cm}

Stockage :
\inferrule
    { len(B_E) = x}
    {\regPP{E}{J}{S}{W}{B_E}{} \\ \xRightarrow{\text{?ev(id,rel)}} \\ \regPP{E}{J}{S}{W}{\majtab{B_E}{x+1}{(id, rel)}}{}}
\vspace{0.5cm}

Event :
\inferrule
    { Head(B_E) = (id, rel) \\ apply(R, id, rel) = (R',c)}
    {R \xRightarrow{\text{!(id,c)}} R'}
\vspace{0.5cm}

\subsubsection{Approche petits pas}

Pour cette approche, on ajoute au régulateur un buffer d'événements $B_E$ qui contient les événements en 
attente d'être traités, et un tableau des "réponses" $A$ qui contient la réponse à l'événements.
\vspace{0.5cm}

Stockage :
\inferrule
    { len(B_E) = x}
    {\regPP{E}{J}{S}{W}{B_E}{A} \\ \xRightarrow{\text{?ev(id,rel)}} \\ \regPP{E}{J}{S}{W}{\majtab{B_E}{x+1}{(id, rel)}}{A}}
\vspace{0.5cm}

incr$_{bf}$ : %incr qui arrive avant un att
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ J[j] = x \\ W[(j, x+1)] = \varepsilon }
    {\regPP{E[ev] \owns \concat{incr(j)}{P'}}{J}{S}{W}{B_E}{A} \\ \Rightarrow \\ \regPP{\majtab{E}{ev}{P'}}{\majtab{J}{j}{x+1}}{S}{W}{B_E}{A}}
\vspace{0.5cm}

incr$_{af}$ : %incr qui arrive après un att
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ J[j] = x \\ W[(j, x+1)] = w_{id} \\ nextEv(w_{id},E) = c}
    {\regPP{E[ev] \owns \concat{incr(j)}{P'}}{J}{S}{W}{B_E}{A} \\ \Rightarrow \\ \regPP{\majtab{E}{ev}{P'}}{\majtab{J}{j}{x+1}}{S}{W}{B_E}{A \gets c}}
\vspace{0.5cm}

att$_{bf}$ : %att qui arrive avant un incr
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ J[j] = x \\ x \neq y}
    {\regPP{E[ev] \owns \concat{att(j,y)}{P'}}{J}{S}{W}{B_E}{A} \\ \Rightarrow \\ \regPP{\majtab{E}{ev}{P'}}{J}{S}{{\majtab{W}{(j,y)}{id}}}{B_E}{A}}
\vspace{0.5cm}

att$_{af}$ : %att qui arrive après un incr
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ J[j] = x \\ nextEv(w_{id},E) = c}
    {\regPP{E[ev] \owns \concat{att(j,x)}{P'}}{J}{S}{W}{B_E}{A} \\ \Rightarrow \\ \regPP{\majtab{E}{ev}{P'}}{J}{S}{W}{B_E}{A \gets c}}
\vspace{0.5cm}

turn : 
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ nextEv(w_{id},R) = c}
    {\regPP{E[ev] \owns \concat{turn(id_{s},state)}{P'}}{J}{S}{W}{B_E}{A} \\ \Rightarrow \\ \regPP{\majtab{E}{ev}{P'}}{J}{\majtab{S}{id_{s}}{state}}{W}{B_E}{A \gets c}}
\\Attention, turn dans les events du train concerné (à cause du nextEv) / ou rajouter l'id du train concerné dans les paramètres de turn
\vspace{0.5cm}

SendAuth :
\inferrule
    { Head(B_E) = (id, rel) \\ ev = (id, rel) \\ suppl = A }
    {\regPP{E[ev] \owns \varepsilon}{J}{S}{W}{B_E \owns \concat{ev}{M'}}{A} \\ \xRightarrow{\text{!(id,suppl)}} \\ \regPP{E}{J}{S}{W}{B_E}{A \gets \varepsilon}}
\vspace{0.5cm}


\end{document}