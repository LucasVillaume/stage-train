\documentclass[12pt]{article}
\usepackage{package/formal-grammar}
\usepackage{package/mathpartir}
\usepackage{package/algorithm}
\usepackage{package/algpseudocode}
\usepackage{graphicx}



\title{Brouillon règles}
\author{}

\begin{document}

%%%%% Macro %%%%%%%
\newcommand\concat[2]{#1;#2}
\newcommand\train[4]{(#1, #2, #3, #4)}
\newcommand\trainfull[4]{\Gamma \cup \train{#1}{#2}{#3}{#4}}
 

\newcommand\ruleStart[3]{ %1 id, 2 pos, 3 D
    \inferrule
    { }
    {\trainfull{#1}{#2}{*}{\concat{Start(#3)}{P'}}, R \Rightarrow \trainfull{#1}{#2}{#3}{P'}, R} 
}

\newcommand\ruleStop[3]{ %1 id, 2 pos, 3 dir
    \inferrule
    { }
    {\trainfull{#1}{#2}{#3}{\concat{Stop()}{P'}}, R \Rightarrow \trainfull{#1}{#2}{*}{P'}, R} 
}

\newcommand\ruleUntil[5]{ %1 id, 2 pos, 3 dir, 4 pos', 5 N
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#5)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{\concat{Until(#5)}{P'}}, R}
}


\newcommand\ruleUntilCons[4]{ %1 id, 2 pos, 3 dir, 4 pos'
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#4)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{P'}, R}
}

\newcommand\ruleUntilEv[5]{ %1 id, 2 pos, 3 dir, 4 pos', 5 N
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2 \\ ev(#1, #4) \in R.E \\ apply(R, ev(#1, #4)) = R'}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#5)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{\concat{Until(#5)}{P'}}, R'}
}

\newcommand\ruleUntilConsEv[4]{ %1 id, 2 pos, 3 dir, 4 pos'
    \inferrule
    { suiv(#2, #3) = #4 \\ #2 \neq #4 \\ R.A[#1] \neq #2 \\ ev(#1, #4) \in R.E \\ apply(R, ev(#1, #4)) = R'}
    {\trainfull{#1}{#2}{#3}{\concat{Until(#4)}{P'}}, R \Rightarrow \trainfull{#1}{#4}{#3}{P'}, R'}
}

\newcommand\ruleWait[4]{ %1 id, 2 pos, 3 dir, 4 x,y
    \inferrule
    {R.A[#1] = #2 \\ ev(#1,#2) \in R.E \\ R.E[ev[#1, #2]].P = att(#4)  \\ apply(R, ev(#1, #2)) = R'}
    {\trainfull{#1}{#2}{#3}{P}, R \Rightarrow \trainfull{#1}{#2}{#3}{P}, R'}
}

\newcommand\ruleCrash[2]{ %1 id, 2 id'
    \inferrule
        {#1 \neq #2}
        {\Gamma, \train{#1}{pos}{dir}{P}, \train{#2}{pos}{dir'}{P'}  \Rightarrow \bot}
}

\newcommand\ruleCrashSec[3]{ %1 id, 2 pos, 3 dir
    \inferrule
        {\lnot suiv(#2, #3) = \emptyset \\ #3 \neq * \\ R.A[#1] \neq #2}
        {\trainfull{#1}{#2}{#3}{P}, R \Rightarrow \bot}
}


\maketitle


\section{Définition}

\subsection{Représentation du train}
Dans notre modèle, un train est représenté par un quadruplet $(id, pos, dir, P)$ où :
\begin{itemize}
    \item $id$ : identifiant du train
    \item $pos$ : position du train 
    \item $dir$ : direction du train
    \item $P$ : programme du train
\end{itemize}

\subsection{Représentation du régulateur}
Le régulateur est représenté par un sextuplet $(J, A, E, N_e, W, S)$ où :
\begin{itemize}
    \item $J$ : tableau de jetons
    \item $A$ : tableau des autorisations
    \item $E$ : événements du régulateur
    \item $N_e$ : tableau des numéros des prochains événements
    \item $W$ : file d'attente
    \item $S$ : tableau des aiguillages
\end{itemize}

\subsection{Définition des prédicats et fonctions}

\begin{itemize}
    \item $suiv(pos, dir, switch)$ : renvoi la position suivante 
    \item $switchRes(id, switch)$ : vérifie si le train $id$ peut emprunter l'aiguillage $switch$
    \item $apply(ev)$ : applique l'événement $ev$ au régulateur : 
    \begin{itemize}
        \item incr(j) : incrémente la valeur du jeton $j$ de 1 et remet en marche le train bloqué
        \item att(p, v) : mets le train en attente du jeton de valeur $v$ pour le canton $p$
    \end{itemize}
\end{itemize}

%Pseudocode pour les fonctions du régulateur
\begin{algorithm}
\caption{Fonction incr}
    \begin{algorithmic}[1]
        \Function{incr}{j} \Comment{j : index du jeton}
            \State R.J[j] $\gets$ R.J[j] + 1
            \State $id \gets waiting(j,J[j])$ \Comment{Cherche l'id du train en attente}
            \If{$id \neq \emptyset$}
                \State delete(R.W, (j,J[j])) \Comment{Supprime le triplet de W}
                \State $R.A[id] \gets nextEvent(id)$ \Comment{Si nextEvent vide, alors until} 
                %Si nextEvent(id) est vide, alors on prend le numéro du prochian until
                %transformer nextEvent en nextAtt : en gros, on cherche le prochain event à avoir un att (si pas, alors prochain until)
            \EndIf
            \State pop(R.E[ev].P) \Comment{Dépile l'ordre de l'event}
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Fonction att}
        \begin{algorithmic}[2]
        \Function{att}{p, v} \Comment{p : position, v : valeur du veton}
            \If{R.J[p] $\neq$ v}
                \State R.A[p] $\gets$ -1
                \State R.W $\gets$ \concat{R.W}{(id, p, v)} \Comment{id issue de event (le passer en arg ?)}
            \Else \Comment{R.J[p] = v}
                \State R.A[p] $\gets$ nextEvent(id)
            \EndIf
            \State pop(R.E[ev].P) \Comment{Dépile l'ordre de l'event}
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}
    \caption{Fonction apply}
        \begin{algorithmic}[3]
        \If{R.E[ev].P = att(p, v)}
            \State att(p, v)
        \ElsIf{R.E[ev].P = incr(j)}
            \State incr(j)
        \ElsIf{R.E[ev].P = switch(id$_{switch}$, state)}  
            \State turn(id$_{switch}$, state)
        \EndIf

        \If{R.E[ev].P = $\emptyset$} 
            pop(R.E[ev]) \Comment{Supprime l'event}
        \EndIf
    \end{algorithmic}
\end{algorithm}

%%%%% Grammaire %%%%%%

\section{Grammaire}



\begin{grammar}[Grammaire des trains][h][train]
    \firstcasesubtil{T}{\concat{seq}{T}}{}
    \otherform{\varepsilon }{}
    \firstcasesubtil{seq}{StartUntil(D,N)}{}
    \firstcasesubtil{D}{L \gralt R}{}
    \firstcasesubtil{N}{0 \gralt 1 \gralt ... \gralt 8}{} 
\end{grammar}

\vspace{0.5cm}

\begin{grammar}[Grammaire du régulateur][h][regulateur]
    \firstcasesubtil{R}{\varepsilon}{}
    \otherform{stmt || R}{}
    \firstcasesubtil{stmt}{ev(id_{train}, pos, num_{event}) : atom}{}
    \firstcasesubtil{atom}{\concat{switch}{order}}{}
    \firstcasesubtil{switch}{\concat{turn(id_{switch}, state)}{switch}}{}
    \otherform{\varepsilon}{}
    \firstcasesubtil{order}{incr(j) \gralt att(j, value_{j})}{}
    \otherform{\concat{incr(j)}{att(j', value_{j'})}}{}
\end{grammar}

%%%%%% Règles %%%%%%

\newpage
\section{Règles}


Start : 
\inferrule
    { dir \neq D}
    {\trainfull{id}{pos}{dir}{\concat{SU(D,N)}{P'}}, R \Rightarrow \trainfull{id}{pos}{D}{\concat{SU(D,N)}{P'}}, R} 
\vspace{0.5cm}


Stop :
\inferrule
    { P = \varepsilon \\ dir \neq *}
    {\trainfull{id}{pos}{dir}{P}, R \Rightarrow \trainfull{id}{pos}{*}{P}, R} 
\vspace{0.5cm}


Until :
\inferrule
    { suiv(pos, D, R.S) = pos' \\ N \neq pos' \\ R.A[id] \neq pos \\ ev(id, pos') \notin R.E}
    {\trainfull{id}{pos}{D}{\concat{SU(D,N)}{P'}}, R \Rightarrow \trainfull{id}{pos'}{D}{\concat{SU(N)}{P'}}, R}
\vspace{0.5cm}


Until' :
    \inferrule
        { suiv(pos, D, R.S) = pos' \\ R.A[id] \neq pos \\ ev(id, pos') \notin R.E }
        {\trainfull{id}{pos}{D}{\concat{SU(D,pos')}{P'}}, R \Rightarrow \trainfull{id}{pos'}{D}{P'}, R}
\vspace{0.5cm}


Until$_{ev}$ :
    \inferrule
    { suiv(pos, D, R.S) = pos' \\ N \neq pos' \\ R.A[id] \neq pos \\ ev(id, pos') \in R.E \\ apply(R, ev(id, pos)) = R'}
    {\trainfull{id}{pos}{D}{\concat{SU(D,N)}{P'}}, R \Rightarrow \trainfull{id}{pos'}{D}{\concat{SU(U,N)}{P'}}, R'}
\vspace{0.5cm}


Until'$_{ev}$ :
    \inferrule
        { suiv(pos, D, R.S) = pos' \\ R.A[id] \neq pos \\ ev(id, pos') \in R.E \\ apply(R, ev(id, pos)) = R'}
        {\trainfull{id}{pos}{D}{\concat{SU(D,pos')}{P'}}, R \Rightarrow \trainfull{id}{pos'}{D}{P'}, R'}
\vspace{0.5cm}

%Wait :
%    \inferrule
%    {R.A[id] = pos \\ ev(id,pos) \in R.E \\ R.E[ev[id, pos]].P = att(x,y)  \\ apply(R, ev(id, pos)) = R'}
%    {\trainfull{id}{pos}{dir}{P}, R \Rightarrow \trainfull{id}{pos}{dir}{P}, R'}
%\\
%La règle Wait traite le cas particulier où le train démarre et doit directement attendre. Peut la simplifier.
%\vspace{0.5cm}

%Crash : %en suspend
%    \inferrule
%        {id \neq id'}
%        {\Gamma, \train{id}{pos}{dir}{P}, \train{id'}{pos}{dir'}{P'}  \Rightarrow \bot}
%\vspace{0.5cm}


%Crash': %en suspend
%    \inferrule
%        {suiv(p, dir) = \emptyset \\ dir \neq * \\ R.A[id] \neq p}
%        {\trainfull{id}{p}{dir}{P}, R \Rightarrow \bot}


\end{document}